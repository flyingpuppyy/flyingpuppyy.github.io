<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="明昧">
    
    <title>
        
            20240620 C++ 互斥量/C++并发编程实战（二） |
        
        行者无畏
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"flyingpuppyy.github.io","root":"/","language":"zh-Hans"}
    KEEP.theme_config = {"base_info":{"primary_color":"#FA8072","title":"行者无畏","author":"明昧","avatar":"/images/tou.jpeg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives","categories":"/categories"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"没有一条路径通往真诚 真诚本身就是道路","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":false,"preload":false},"comment":{"enable":true,"use":"valine","valine":{"appid":"DYpeXIX0A58ayXv2jFns418I-gzGzoHsz","appkey":"aVeRlE1OlBTUKleFs6ZKOrga","server_urls":null,"placeholder":"╲╱__ ╭の╮ ┈不管结局如何ヾ 是否完美゛ .我都不会放弃!"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":false,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"encrypt":{"enable":true},"markdown":{"preset":"default","render":{"html":true,"xhtmlOut":false,"langPrefix":"language-","breaks":true,"linkify":true,"typographer":true,"quotes":"“”‘’"},"enable_rules":null,"disable_rules":null,"plugins":["markdown-it-abbr","markdown-it-cjk-breaks","markdown-it-deflist","markdown-it-emoji","markdown-it-footnote","markdown-it-ins","markdown-it-mark","markdown-it-sub","markdown-it-sup",{"name":"markdown-it-container","options":"success"},{"name":"markdown-it-container","options":"tips"},{"name":"markdown-it-container","options":"warning"},{"name":"markdown-it-container","options":"danger"}],"anchors":{"level":2,"collisionSuffix":"","permalink":false,"permalinkClass":"header-anchor","permalinkSide":"left","permalinkSymbol":"¶","case":0,"separator":"-"}},"root":"","source_data":{},"version":"4.1.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               行者无畏
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                首页
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                归档
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                
                                分类
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >首页</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        20240620 C++ 互斥量/C++并发编程实战（二）
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/tou.jpeg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">明昧</span>
                                
                                    <span class="author-badge">Lv6</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-06-20 21:37:38</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Thu Jun 20 2024 21:38:54 GMT+0800">2024-06-20 21:38:54</span>
            </span>
        

        

        

        
        
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <h1 id="32-使用互斥量保护共享数据"><a class="markdownIt-Anchor" href="#32-使用互斥量保护共享数据"></a> 3.2 使用互斥量保护共享数据</h1>
<p>当程序中有共享数据，肯定不想让其陷入条件竞争，或是不变量被破坏。那么，将所有访问共享数据结构的代码都标记为互斥岂不是更好？这样任何一个线程在执行这些代码时，其他任何线程试图访问共享数据结构，就必须等到那一段代码执行结束。于是，一个线程就不可能会看到被破坏的不变量，除非它本身就是修改共享数据的线程。</p>
<p>当访问共享数据前，使用互斥量将相关数据锁住，再当访问结束后，再将数据解锁。线程库需要保证，当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后，才能进行访问。这就保证了所有线程能看到共享数据，而不破坏不变量。</p>
<p><strong>互斥量是<code>C++</code>中一种最通用的数据保护机制，但它不是“银弹”；精心组织代码来保护正确的数据(见3.2.2节)，并在接口内部避免竞争条件(见3.2.3节)是非常重要的。</strong></p>
<p><strong>但互斥量自身也有问题，也会造成死锁(见3.2.4节)，或是对数据保护的太多(或太少)(见3.2.8节)。</strong></p>
<h2 id="321-c中使用互斥量"><a class="markdownIt-Anchor" href="#321-c中使用互斥量"></a> 3.2.1 C++中使用互斥量</h2>
<p>C++中通过实例化<code>std::mutex</code>创建互斥量，通过调用成员函数lock()进行上锁，unlock()进行解锁。</p>
<p>不过，不推荐实践中直接去调用成员函数，因为调用成员函数就意味着，必须记住在每个函数出口都要去调用unlock()，也包括异常的情况。C++标准库为互斥量提供了一个RAII语法的模板类<code>std::lock_guard</code>，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁。下面的程序清单中，展示了如何在多线程程序中，<strong>使用<code>std::mutex</code>构造的<code>std::lock_guard</code>实例，对一个列表进行访问保护。<code>std::mutex</code>和<code>std::lock_guard</code>都在<code>&lt;mutex&gt;</code>头文件中声明。</strong></p>
<p>清单3.1 使用互斥量保护列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">std::list&lt;int&gt; some_list;    // 1</span><br><span class="line">std::mutex some_mutex;    // 2</span><br><span class="line"></span><br><span class="line">void add_to_list(int new_value)</span><br><span class="line">&#123;</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; guard(some_mutex);    // 3</span><br><span class="line">  some_list.push_back(new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool list_contains(int value_to_find)</span><br><span class="line">&#123;</span><br><span class="line">  std::lock_guard&lt;std::mutex&gt; guard(some_mutex);    // 4</span><br><span class="line">  return std::find(some_list.begin(),some_list.end(),value_to_find) != some_list.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清单3.1中有一个全局变量①，这个全局变量被一个全局的互斥量保护②。add_to_list()③和list_contains()④函数中使用<code>std::lock_guard&lt;std::mutex&gt;</code>，使得这两个函数中对数据的访问是互斥的：list_contains()不可能看到正在被add_to_list()修改的列表。</p>
<p>**虽然某些情况下，使用全局变量没问题，但在大多数情况下，互斥量通常会与保护的数据放在同一个类中，而不是定义成全局变量。这是面向对象设计的准则：将其放在一个类中，就可让他们联系在一起，也可对类的功能进行封装，并进行数据保护。**在这种情况下，函数add_to_list和list_contains可以作为这个类的成员函数。互斥量和要保护的数据，在类中都需要定义为private成员，这会让访问数据的代码变的清晰，并且容易看出在什么时候对互斥量上锁。当所有成员函数都会在调用时对数据上锁，结束时对数据解锁，那么就保证了数据访问时不变量不被破坏。</p>
<p><strong>当然，也不是总是那么理想，聪明的你一定注意到了：当其中一个成员函数返回的是保护数据的指针或引用时，会破坏对数据的保护。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制。互斥量保护的数据需要对接口的设计相当谨慎，要确保互斥量能锁住任何对保护数据的访问，并且不留后门。</strong></p>
<h2 id="322-精心组织代码来保护共享数据"><a class="markdownIt-Anchor" href="#322-精心组织代码来保护共享数据"></a> 3.2.2 精心组织代码来保护共享数据</h2>
<p>使用互斥量来保护数据，并不是仅仅在每一个成员函数中都加入一个<code>std::lock_guard</code>对象那么简单；</p>
<p>一个迷失的指针或引用，将会让这种保护形同虚设。不过，检查迷失指针或引用是很容易的，只要没有成员函<strong>数通过返回值或者输出参数的形式向其调用者返回指向受保护数据的指针或引用</strong>，数据就是安全的。如果你还想往祖坟上刨，就没这么简单了。</p>
<p>在确保成员函数不会传出指针或引用的同时，检查成员函数<strong>是否通过指针或引用的方式来调用也是很重要的</strong>(尤其是这个操作不在你的控制下时)。函数可能没在互斥量保护的区域内，存储着指针或者引用，这样就很危险。更危险的是：将保护数据作为一个运行时参数，如同下面清单中所示那样。</p>
<p>清单3.2 无意中传递了保护数据的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">some_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  std::string b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">do_something</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">data_wrapper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_data data;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">process_data</span><span class="params">(Function func)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">func</span>(data);    <span class="comment">// 1 传递“保护”数据给用户函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data* unprotected;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  unprotected=&amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">process_data</span>(malicious_function);    <span class="comment">// 2 传递一个恶意函数</span></span><br><span class="line">  unprotected-&gt;<span class="built_in">do_something</span>();    <span class="comment">// 3 在无保护的情况下访问保护数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子中process_data看起来没有任何问题，<code>std::lock_guard</code>对数据做了很好的保护，但调用用户提供的函数func①，就意味着foo能够绕过保护机制将函数<code>malicious_function</code>传递进去②，在没有锁定互斥量的情况下调用<code>do_something()</code>。</p>
<p>这段代码的问题在于根本没有保护，只是将所有可访问的数据结构代码标记为互斥。函数<code>foo()</code>中调用<code>unprotected-&gt;do_something()</code>的代码未能被标记为互斥。这种情况下，C++线程库无法提供任何帮助，只能由程序员来使用正确的互斥锁来保护数据。从乐观的角度上看，还是有方法可循的：<strong>切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。</strong></p>
<p>虽然这是在使用互斥量保护共享数据时常犯的错误，但绝不仅仅是一个潜在的陷阱而已。下一节中，你将会看到，即便是使用了互斥量对数据进行了保护，条件竞争依旧可能存在。</p>
<blockquote>
<p>void foo()<br />
{<br />
x.process_data(malicious_function);    // 2 传递一个恶意函数<br />
unprotected-&gt;do_something();    // 3 在无保护的情况下访问保护数据<br />
}</p>
<p>因为这个函数的存在因而我们从别的地方拿到了本来不应该获取到互斥数据量保护</p>
</blockquote>
<h2 id="323-发现接口内在的条件竞争"><a class="markdownIt-Anchor" href="#323-发现接口内在的条件竞争"></a> <mark>3.2.3 发现接口内在的条件竞争</mark></h2>
<p>因为使用了互斥量或其他机制保护了共享数据，就不必再为条件竞争所担忧吗？</p>
<p>并不是，你依旧需要确定数据受到了保护。回想之前双链表的例子，为了能让线程安全地删除一个节点，需要确保防止对这三个节点(待删除的节点及其前后相邻的节点)的并发访问。如果只对指向每个节点的指针进行访问保护，那就和没有使用互斥量一样，条件竞争仍会发生——<strong>除了指针，整个数据结构和整个删除操作需要保护。这种情况下最简单的解决方案就是使用互斥量来保护整个链表，如清单3.1所示。</strong></p>
<blockquote>
<p>竞争发生点将会影响的数据以及波及的范围和操作权限是值得我们注意的</p>
<p>不单单只是对需要修改的数据进行保护</p>
</blockquote>
<p>尽管链表的个别操作是安全的，但不意味着你就能走出困境；即使在一个很简单的接口中，依旧可能遇到条件竞争。</p>
<p>例如，构建一个类似于<code>std::stack</code>结构的栈(清单3.3)，除了构造函数和swap()以外，需要对<code>std::stack</code>提供五个操作：push()一个新元素进栈，pop()一个元素出栈，top()查看栈顶元素，empty()判断栈是否是空栈，size()了解栈中有多少个元素。即使修改了top()，<mark>使其返回一个拷贝而非引用(即遵循了3.2.2节的准则)</mark>，对内部数据使用一个互斥量进行保护，不过这个接口仍存在条件竞争。这个问题不仅存在于基于互斥量实现的接口中，在无锁实现的接口中，条件竞争依旧会产生。这是接口的问题，与其实现方式无关。</p>
<blockquote>
<p>没看出来竞争在哪</p>
</blockquote>
<p>清单3.3 <code>std::stack</code>容器的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Container=std::deque&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> <span class="built_in">stack</span>(<span class="type">const</span> Container&amp;);</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(Container&amp;&amp; = Container())</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(<span class="type">const</span> Alloc&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">stack</span>(<span class="type">const</span> Container&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">stack</span>(Container&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Alloc</span>&gt; <span class="built_in">stack</span>(stack&amp;&amp;, <span class="type">const</span> Alloc&amp;);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">T <span class="type">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(stack&amp;&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>虽然empty()和size()可能在被调用并返回时是正确的，但其的结果是不可靠的；当它们返回后，其他线程就可以自由地访问栈，并且可能push()多个新元素到栈中，也可能pop()一些已在栈中的元素。这样的话，之前从empty()和size()得到的结果就有问题了。</strong></p>
<blockquote>
<p>bool empty() const;</p>
<p>size_t size() const;</p>
<p>你的意思是对于一个数据结构的函数来说</p>
<p>获取到的数据不一定是即时准确的？</p>
</blockquote>
<p>特别地，当栈实例是非共享的，如果栈非空，使用empty()检查再调用top()访问栈顶部的元素是安全的。如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="keyword">if</span> (! s.<span class="built_in">empty</span>())&#123;    <span class="comment">// 1</span></span><br><span class="line">  <span class="type">int</span> <span class="type">const</span> value = s.<span class="built_in">top</span>();    <span class="comment">// 2</span></span><br><span class="line">  s.<span class="built_in">pop</span>();    <span class="comment">// 3</span></span><br><span class="line">  <span class="built_in">do_something</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是单线程安全代码：对一个空栈使用top()是未定义行为。</p>
<p><mark>对于共享的栈对象，这样的调用顺序就不再安全了，因为在调用empty()①和调用top()②之间，可能有来自另一个线程的pop()调用并删除了最后一个元素。这是一个经典的条件竞争，使用互斥量对栈内部数据进行保护，但依旧不能阻止条件竞争的发生，这就是接口固有的问题。</mark></p>
<p>怎么解决呢？问题发生在接口设计上，所以解决的方法也就是改变接口设计。有人会问：怎么改？在这个简单的例子中，<strong>当调用top()时，发现栈已经是空的了，那么就抛出异常。虽然这能直接解决这个问题，但这是一个笨拙的解决方案，这样的话，即使empty()返回false的情况下，你也需要异常捕获机制。本质上，这样的改变会让empty()成为一个多余函数。</strong></p>
<p>当仔细的观察过之前的代码段，就会发现另一个潜在的条件竞争在调用top()②和pop()③之间。假设两个线程运行着前面的代码，并且都引用同一个栈对象s。这并非罕见的情况，当为性能而使用线程时，多个线程在不同的数据上执行相同的操作是很平常的，并且共享同一个栈可以将工作分摊给它们。假设，一开始栈中只有两个元素，这时任一线程上的empty()和top()都存在竞争，只需要考虑可能的执行顺序即可。</p>
<p><strong>当栈被一个内部互斥量所保护时，只有一个线程可以调用栈的成员函数</strong>，所以调用可以很好地交错，并且do_something()是可以并发运行的。在表3.1中，展示一种可能的执行顺序。</p>
<p><strong>表3.1 一种可能执行顺序</strong></p>
<table>
<thead>
<tr>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody>
<tr>
<td>if (!s.empty);</td>
<td></td>
</tr>
<tr>
<td></td>
<td>if(!s.empty);</td>
</tr>
<tr>
<td>int const value = s.top();</td>
<td></td>
</tr>
<tr>
<td></td>
<td>int const value = s.top();</td>
</tr>
<tr>
<td>s.pop();</td>
<td></td>
</tr>
<tr>
<td>do_something(value);</td>
<td>s.pop();</td>
</tr>
<tr>
<td></td>
<td>do_something(value);</td>
</tr>
</tbody>
</table>
<p><strong>当线程运行时，调用两次top()，栈没被修改，所以每个线程能得到同样的值。不仅是这样，在调用top()函数调用的过程中(两次)，pop()函数都没有被调用。这样，在其中一个值再读取的时候，虽然不会出现“写后读”的情况，但其值已被处理了两次。这种条件竞争，比未定义的empty()/top()竞争更加严重；虽然其结果依赖于do_something()的结果，但因为看起来没有任何错误，就会让这个Bug很难定位。</strong></p>
<p>这就需要接口设计上有较大的改动，</p>
<p>提议之一就是使用同一互斥量来保护top()和pop()。Tom Cargill[1]指出当一个对象的拷贝构造函数在栈中抛出一个异常，这样的处理方式就会有问题。</p>
<p>在Herb Sutter[2]看来，这个问题可以从“异常安全”的角度完美解决，不过潜在的条件竞争，可能会组成一些新的组合。</p>
<hr />
<p>说一些大家没有意识到的问题：假设有一个<code>stack&lt;vector&lt;int&gt;&gt;</code>，vector是一个动态容器，当你拷贝一个vetcor，标准库会从堆上分配很多内存来完成这次拷贝。当这个系统处在重度负荷，或有严重的资源限制的情况下，这种内存分配就会失败，所以vector的拷贝构造函数可能会抛出一个<code>std::bad_alloc</code>异常。当vector中存有大量元素时，这种情况发生的可能性更大。</p>
<p>当pop()函数返回“弹出值”时(也就是从栈中将这个值移除)，会有一个潜在的问题：这个值被返回到调用函数的时候，栈才被改变；<strong>但当拷贝数据的时候，调用函数抛出一个异常会怎么样？ 如果事情真的发生了，要弹出的数据将会丢失；它的确从栈上移出了，但是拷贝失败了！</strong></p>
<p><code>std::stack</code>的设计人员将这个操作分为两部分：先获取顶部元素(top())，然后从栈中移除(pop())。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。当问题是堆空间不足，应用可能会释放一些内存，然后再进行尝试。</p>
<p>不幸的是，这样的分割却制造了本想避免或消除的条件竞争。幸运的是，我们还有的别的选项，但是使用这些选项是要付出代价的。</p>
<hr />
<p><strong>选项1： 传入一个引用</strong></p>
<p>第一个选项是将变量的引用作为参数，传入pop()函数中获取想要的“弹出值”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; result;</span><br><span class="line">some_stack.pop(result);</span><br></pre></td></tr></table></figure>
<p>大多数情况下，这种方式还不错，但有明显的缺点：需要构造出一个栈中类型的实例，用于接收目标值。对于一些类型，这样做是不现实的，<strong>因为临时构造一个实例，从时间和资源的角度上来看，都是不划算</strong>。对于其他的类型，这样也不总能行得通，因为构造函数需要的一些参数，在代码的这个阶段不一定可用。</p>
<p><mark>最后，需要可赋值的存储类型，这是一个重大限制：即使支持移动构造，甚至是拷贝构造(从而允许返回一个值)，很多用户自定义类型可能都不支持赋值操作。</mark></p>
<p><strong>选项2：无异常抛出的拷贝构造函数或移动构造函数</strong></p>
<p>对于有返回值的pop()函数来说，只有“异常安全”方面的担忧(当返回值时可以抛出一个异常)。很多类型都有拷贝构造函数，它们不会抛出异常，并且随着新标准中对“右值引用”的支持(详见附录A，A.1节)，很多类型都将会有一个移动构造函数，即使他们和拷贝构造函数做着相同的事情，它也不会抛出异常。</p>
<p>一个有用的选项可以限制对线程安全的栈的使用，并且能让栈安全的返回所需的值，而不会抛出异常。</p>
<p>虽然安全，但非可靠。尽管能在编译时可使用<code>std::is_nothrow_copy_constructible</code>和<code>std::is_nothrow_move_constructible</code>类型特征，让拷贝或移动构造函数不抛出异常，但是这种方式的局限性太强。用户自定义的类型中，会有不抛出异常的拷贝构造函数或移动构造函数的类型， 那些有抛出异常的拷贝构造函数，但没有移动构造函数的类型往往更多（这种情况会随着人们习惯于C++11中的右值引用而有所改变)。如果这些类型不能被存储在线程安全的栈中，那将是多么的不幸。</p>
<blockquote>
<p>这个解决方案究竟在说什么，难道没有异常抛出问题本身就不存在了吗？</p>
<p>这个方案的关注点我确实不太懂</p>
</blockquote>
<p><strong>、选项3：返回指向弹出值的指针</strong></p>
<p>第三个选择是返回一个指向弹出元素的指针，而不是直接返回值。指针的优势是自由拷贝，并且不会产生异常，这样你就能避免Cargill提到的异常问题了。缺点就是返回一个指针需要对对象的内存分配进行管理，对于简单数据类型(比如：int)，内存管理的开销要远大于直接返回值。</p>
<p>对于选择这个方案的接口，使用<code>std::shared_ptr</code>是个不错的选择；不仅能避免内存泄露(因为当对象中指针销毁时，对象也会被销毁)，而且标准库能够完全控制内存分配方案，也就不需要new和delete操作。这种优化是很重要的：因为堆栈中的每个对象，都需要用new进行独立的内存分配，相较于非线程安全版本，这个方案的开销相当大。</p>
<blockquote>
<p>这里看不懂</p>
</blockquote>
<p><strong>选项4：“选项1 + 选项2”或 “选项1 + 选项3”</strong></p>
<p>对于通用的代码来说，灵活性不应忽视。当你已经选择了选项2或3时，再去选择1也是很容易的。这些选项提供给用户，让用户自己选择对于他们自己来说最合适，最经济的方案。</p>
<p><strong>例：定义线程安全的堆栈</strong></p>
<p>清单3.4中是一个接口没有条件竞争的堆栈类定义，它实现了选项1和选项3：重载了pop()，使用一个局部引用去存储弹出值，并返回一个<code>std::shared_ptr&lt;&gt;</code>对象。它有一个简单的接口，只有两个函数：push()和pop();</p>
<p>清单3.4 线程安全的堆栈类定义(概述)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// For std::shared_ptr&lt;&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">empty_stack</span>: std::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">threadsafe_stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>();</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>(<span class="type">const</span> threadsafe_stack&amp;);</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="type">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>; <span class="comment">// 1 赋值操作被删除</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>削减接口可以获得最大程度的安全,甚至限制对栈的一些操作。栈是不能直接赋值的，因为赋值操作已经删除了①(详见附录A，A.2节)，并且这里没有swap()函数。栈可以拷贝的，假设栈中的元素可以拷贝。当栈为空时，pop()函数会抛出一个empty_stack异常，所以在empty()函数被调用后，其他部件还能正常工作。如选项3描述的那样，使用<code>std::shared_ptr</code>可以避免内存分配管理的问题，并避免多次使用new和delete操作。堆栈中的五个操作，现在就剩下三个：push(), pop()和empty()(这里empty()都有些多余)。简化接口更有利于数据控制，可以保证互斥量将一个操作完全锁住。下面的代码将展示一个简单的实现——封装<code>std::stack&lt;&gt;</code>的线程安全堆栈。</p>
<p>清单3.5 扩充(线程安全)堆栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">struct empty_stack: std::exception</span><br><span class="line">&#123;</span><br><span class="line">  const char* what() const throw() &#123;</span><br><span class="line">	return &quot;empty stack!&quot;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class threadsafe_stack</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">  std::stack&lt;T&gt; data;</span><br><span class="line">  mutable std::mutex m;</span><br><span class="line">  </span><br><span class="line">public:</span><br><span class="line">  threadsafe_stack()</span><br><span class="line">	: data(std::stack&lt;T&gt;())&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  threadsafe_stack(const threadsafe_stack&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(other.m);</span><br><span class="line">    data = other.data; // 1 在构造函数体中的执行拷贝</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadsafe_stack&amp; operator=(const threadsafe_stack&amp;) = delete;</span><br><span class="line"></span><br><span class="line">  void push(T new_value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">    data.push(new_value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  std::shared_ptr&lt;T&gt; pop()</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">    if(data.empty()) throw empty_stack(); // 在调用pop前，检查栈是否为空</span><br><span class="line">	</span><br><span class="line">    std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(data.top())); // 在修改堆栈前，分配出返回值</span><br><span class="line">    data.pop();</span><br><span class="line">    return res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  void pop(T&amp; value)</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">    if(data.empty()) throw empty_stack();</span><br><span class="line">	</span><br><span class="line">    value=data.top();</span><br><span class="line">    data.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bool empty() const</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">    return data.empty();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>堆栈可以拷贝——拷贝构造函数对互斥量上锁，再拷贝堆栈。构造函数体中①的拷贝使用互斥量来确保复制结果的正确性，这样的方式比成员初始化列表好。</p>
<p>之前对top()和pop()函数的讨论中，恶性条件竞争已经出现，因为<strong>锁的粒度太小</strong>，需要保护的操作并未全覆盖到。不过，锁住的颗粒过大同样会有问题。还有一个问题，一个全局互斥量要去保护全部共享数据，在一个系统中存在有大量的共享数据时，因为线程可以强制运行，甚至可以访问不同位置的数据，抵消了并发带来的性能提升。</p>
<p>在第一版为多处理器系统设计Linux内核中，就使用了一个全局内核锁。虽然这个锁能正常工作，但在双核处理系统的上的性能要比两个单核系统的性能差很多，四核系统就更不能提了。太多请求去竞争占用内核，使得依赖于处理器运行的线程没有办法很好的工作。随后修正的Linux内核加入了一个细粒度锁方案，因为少了很多内核竞争，这时四核处理系统的性能就和单核处理的四倍差不多了。</p>
<p>使用多个互斥量保护所有的数据，细粒度锁也有问题。如前所述，当增大互斥量覆盖数据的粒度时，只需要锁住一个互斥量。</p>
<p>但是，这种方案并非放之四海皆准，比如：互斥量正在保护一个独立类的实例；这种情况下，锁的状态的下一个阶段，不是离开锁定区域将锁定区域还给用户，就是有独立的互斥量去保护这个类的全部实例。当然，这两种方式都不理想。</p>
<p><strong>一个给定操作需要两个或两个以上的互斥量时，另一个潜在的问题将出现：死锁。与条件竞争完全相反——不同的两个线程会互相等待，从而什么都没做。</strong></p>
<h2 id="324-死锁问题描述及解决方案"><a class="markdownIt-Anchor" href="#324-死锁问题描述及解决方案"></a> <mark>3.2.4 死锁：问题描述及解决方案</mark></h2>
<p>试想有一个玩具，这个玩具由两部分组成，必须拿到这两个部分，才能够玩。例如，一个玩具鼓，需要一个鼓锤和一个鼓才能玩。现在有两个小孩，他们都很喜欢玩这个玩具。当其中一个孩子拿到了鼓和鼓锤时，那就可以尽情的玩耍了。当另一孩子想要玩，他就得等待另一孩子玩完才行。再试想，鼓和鼓锤被放在不同的玩具箱里，并且两个孩子在同一时间里都想要去敲鼓。之后，他们就去玩具箱里面找这个鼓。其中一个找到了鼓，并且另外一个找到了鼓锤。现在问题就来了，除非其中一个孩子决定让另一个先玩，他可以把自己的那部分给另外一个孩子；但当他们都紧握着自己所有的部分而不给予，那么这个鼓谁都没法玩。</p>
<p>现在没有孩子去争抢玩具，但线程有对锁的竞争：一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。</p>
<p>这样没有线程能工作，因为他们都在等待对方释放互斥量。这种情况就是死锁，<strong>它的最大问题就是由两个或两个以上的互斥量来锁定一个操作。</strong></p>
<p><strong>避免死锁的一般建议，就是让两个互斥量总以相同的顺序上锁：总在互斥量B之前锁住互斥量A</strong>，就永远不会死锁。某些情况下是可以这样用，因为不同的互斥量用于不同的地方。</p>
<p>不过，事情没那么简单，比如：当有多个互斥量保护同一个类的独立实例时，一个操作对同一个类的两个不同实例进行数据的交换操作，为了保证数据交换操作的正确性，就要避免数据被并发修改，并确保每个实例上的互斥量都能锁住自己要保护的区域。</p>
<p>不过，选择一个固定的顺序(例如，实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数)，可能会适得其反：<strong>在参数交换了之后</strong>，两个线程试图在相同的两个实例间进行数据交换时，程序又死锁了！</p>
<p>很幸运，C++标准库有办法解决这个问题，<code>std::lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)。下面的程序清单中，就来看一下怎么在一个简单的交换操作中使用<code>std::lock</code>。</p>
<p>清单3.6 交换操作中使用<code>std::lock()</code>和<code>std::lock_guard</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的std::lock()需要包含&lt;mutex&gt;头文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">some_big_object</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(some_big_object <span class="type">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">    std::<span class="built_in">lock</span>(lhs.m,rhs.m); <span class="comment">// 1</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::adopt_lock)</span></span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::adopt_lock)</span></span>; <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>首先，检查参数是否是不同的实例，因为操作试图获取<code>std::mutex</code>对象上的锁，所以当其被获取时，结果很难预料。(一个互斥量可以在同一线程上多次上锁，标准库中<code>std::recursive_mutex</code>提供这样的功能。详情见3.3.3节)。</strong></p>
<p>然后，调用<code>std::lock()</code>①锁住两个互斥量，并且两个<code>std:lock_guard</code>实例已经创建好②③。提供<code>std::adopt_lock</code>参数除了表示<code>std::lock_guard</code>对象可获取锁之外，还将锁交由<code>std::lock_guard</code>对象管理，而不需要<code>std::lock_guard</code>对象再去构建新的锁。</p>
<p>这样，就能保证在大多数情况下，函数退出时互斥量能被正确的解锁(保护操作可能会抛出一个异常)，也允许使用一个简单的“return”作为返回。</p>
<p>还有，需要注意的是，当使用<code>std::lock</code>去锁lhs.m或rhs.m时，可能会抛出异常；这种情况下，异常会传播到<code>std::lock</code>之外。当<code>std::lock</code>成功的获取一个互斥量上的锁，并且当其尝试从另一个互斥量上再获取锁时，就会有异常抛出，第一个锁也会随着异常的产生而自动释放，所以<code>std::lock</code>要么将两个锁都锁住，要不一个都不锁。</p>
<p>虽然<code>std::lock</code>可以在这情况下(获取两个以上的锁)避免死锁，但它没办法帮助你获取其中一个锁。这时，不得不依赖于开发者的纪律性(译者：也就是经验)，来确保你的程序不会死锁。这并不简单：死锁是多线程编程中一个令人相当头痛的问题，并且死锁经常是不可预见的，因为在大多数时间里，所有工作都能很好的完成。不过，也一些相对简单的规则能帮助写出“无死锁”的代码。</p>
<h2 id="325-避免死锁的进阶指导"><a class="markdownIt-Anchor" href="#325-避免死锁的进阶指导"></a> 3.2.5 避免死锁的进阶指导</h2>
<p>虽然锁是产生死锁的一般原因，但也不排除死锁出现在其他地方。</p>
<p>无锁的情况下，仅需要每个<code>std::thread</code>对象调用join()，两个线程就能产生死锁。这种情况下，没有线程可以继续运行，因为他们正在互相等待。这种情况很常见，一个线程会等待另一个线程，其他线程同时也会等待第一个线程结束，所以三个或更多线程的互相等待也会发生死锁。为了避免死锁，这里的指导意见为：当机会来临时，不要拱手让人。以下提供一些个人的指导建议，如何识别死锁，并消除其他线程的等待。</p>
<p><strong>避免嵌套锁</strong></p>
<p>第一个建议往往是最简单的：**一个线程已获得一个锁时，再别去获取第二个。**如果能坚持这个建议，因为每个线程只持有一个锁，锁上就不会产生死锁。即使互斥锁造成死锁的最常见原因，也可能会在其他方面受到死锁的困扰(比如：线程间的互相等待)。当你需要获取多个锁，使用一个<code>std::lock</code>来做这件事(对获取锁的操作上锁)，避免产生死锁。</p>
<p><strong>避免在持有锁时调用用户提供的代码</strong></p>
<p>第二个建议是次简单的：因为代码是用户提供的，你没有办法确定用户要做什么；用户程序可能做任何事情，包括获取锁。你在持有锁的情况下，调用用户提供的代码；如果用户代码要获取一个锁，就会违反第一个指导意见，并造成死锁(有时，这是无法避免的)。当你正在写一份通用代码，例如3.2.3中的栈，每一个操作的参数类型，都在用户提供的代码中定义，就需要其他指导意见来帮助你。</p>
<p><mark><strong>使用固定顺序获取锁</strong></mark></p>
<p>当硬性条件要求你获取两个以上(包括两个)的锁，并且不能使用<code>std::lock</code>单独操作来获取它们;那么最好在每个线程上，用固定的顺序获取它们获取它们(锁)。3.2.4节中提到一种当需要获取两个互斥量时，<strong>避免死锁的方法：关键是如何在线程之间，以一定的顺序获取锁。</strong></p>
<blockquote>
<p>一些情况下，这种方式相对简单。比如，3.2.3节中的栈——每个栈实例中都内置有互斥量，但是对数据成员存储的操作上，栈就需要带调用用户提供的代码。虽然，可以添加一些约束，对栈上存储的数据项不做任何操作，对数据项的处理仅限于栈自身。这会给用户提供的栈增加一些负担，但是一个容器很少去访问另一个容器中存储的数据，即使发生了也会很明显，所以这对于通用栈来说并不是一个特别沉重的负担。</p>
</blockquote>
<p>其他情况下，这就不会那么简单了，</p>
<blockquote>
<p>例如：3.2.4节中的交换操作，这种情况下你可能同时锁住多个互斥量(但是有时不会发生)。当回看3.1节中那个链表连接例子时，将会看到列表中的每个节点都会有一个互斥量保护。为了访问列表，线程必须获取他们感兴趣节点上的互斥锁。**当一个线程删除一个节点，它必须获取三个节点上的互斥锁：**将要删除的节点，两个邻接节点(因为他们也会被修改)。</p>
<p>同样的，<strong>为了遍历链表</strong>，线程必须保证在获取当前节点的互斥锁前提下，获得下一个节点的锁，要保证指向下一个节点的指针不会同时被修改。一旦下一个节点上的锁被获取，那么第一个节点的锁就可以释放了，因为没有持有它的必要性了。</p>
<hr />
<p><strong>这种“手递手”锁的模式允许多个线程访问列表，为每一个访问的线程提供不同的节点。</strong></p>
<hr />
<p>但是，为了避免死锁，节点必须以同样的顺序上锁：<strong>如果两个线程试图用互为反向的顺序</strong>，使用“手递手”锁遍历列表，他们将执行到列表中间部分时，<strong>发生死锁</strong>。当节点A和B在列表中相邻，当前线程可能会同时尝试获取A和B上的锁。另一个线程可能已经获取了节点B上的锁，并且试图获取节点A上的锁——经典的死锁场景。</p>
<p><strong>当A、C节点中的B节点正在被删除时</strong>，如果有线程在已获取A和C上的锁后，还要获取B节点上的锁时，当一个线程遍历列表的时候，<strong>这样的情况就可能发生死锁</strong>。</p>
<p>这样的线程可能会试图首先锁住A节点或C节点(根据遍历的方向)，但是后面就会发现，它无法获得B上的锁，因为线程在执行删除任务的时候，已经获取了B上的锁，并且同时也获取了A和C上的锁。</p>
</blockquote>
<p>这里提供一种避免死锁的方式，<mark>定义遍历的顺序</mark>，所以一个线程必须先锁住A才能获取B的锁，在锁住B之后才能获取C的锁。这将消除死锁发生的可能性，在不允许反向遍历的列表上。类似的约定常被用来建立其他的数据结构。</p>
<p><strong>使用锁的层次结构</strong></p>
<p>虽然，这对于定义锁的顺序，的确是一个特殊的情况，但锁的层次的意义在于提供对运行时约定是否被坚持的检查。这个建议需要对你的应用进行分层，并且识别在给定层上所有可上锁的互斥量。当代码试图对一个互斥量上锁，在该层锁已被低层持有时，上锁是不允许的。你可以在运行时对其进行检查，通过分配层数到每个互斥量上，以及记录被每个线程上锁的互斥量。下面的代码列表中将展示两个线程如何使用分层互斥。</p>
<p>清单3.7 使用层次锁来避免死锁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>;  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">low_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>; <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">do_low_level_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="type">int</span> some_param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">high_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>; <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">high_level_stuff</span>(<span class="built_in">low_level_func</span>()); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_a</span><span class="params">()</span>  <span class="comment">// 6</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">high_level_func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">other_mutex</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 7</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">other_stuff</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">high_level_func</span>();  <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">do_other_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_b</span><span class="params">()</span> <span class="comment">// 9</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(other_mutex)</span></span>; <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">other_stuff</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread_a()⑥遵守规则，所以它运行的没问题。另一方面，thread_b()⑨无视规则，因此在运行的时候肯定会失败。</p>
<blockquote>
<p>thread_a()调用high_level_func()，让high_level_mutex④上锁(其层级值为10000①)，为了获取high_level_stuff()的参数对互斥量上锁，之后调用low_level_func()⑤。low_level_func()会对low_level_mutex上锁，这就没有问题了，因为这个互斥量有一个低层值5000②。</p>
<hr />
<p>thread_b()运行就不会顺利了。</p>
<p>首先，它锁住了other_mutex⑩，这个互斥量的层级值只有100⑦。这就意味着，超低层级的数据已被保护。当other_stuff()调用high_level_func()⑧时，就违反了层级结构：high_level_func()试图获取high_level_mutex，这个互斥量的层级值是10000，要比当前层级值100大很多。</p>
<p>因此hierarchical_mutex将会产生一个错误，可能会是抛出一个异常，或直接终止程序。</p>
<hr />
</blockquote>
<p>在层级互斥量上产生死锁，是不可能的，因为互斥量本身会严格遵循约定顺序，进行上锁。</p>
<p>这也意味，当多个互斥量在是在同一级上时，不能同时持有多个锁，<strong>所以“手递手”锁的方案需要每个互斥量在一条链上，并且每个互斥量都比其前一个有更低的层级值</strong>，这在某些情况下无法实现。</p>
<blockquote>
<p>看不懂什么是手递手+较低层级的方案</p>
</blockquote>
<p>例子也展示了另一点，<code>std::lock_guard&lt;&gt;</code>模板与用户定义的互斥量类型一起使用。虽然hierarchical_mutex不是<code>C++</code>标准的一部分，但是它写起来很容易；</p>
<p>一个简单的实现在列表3.8中展示出来。尽管它是一个用户定义类型，它可以用于<code>std::lock_guard&lt;&gt;</code>模板中，因为它的实现有三个成员函数为了满足互斥量操作：lock(), unlock() 和 try_lock()。</p>
<p>虽然你还没见过try_lock()怎么使用，但是其使用起来很简单：当互斥量上的锁被一个线程持有，它<strong>将返回false，而不是等待调用的线程，直到能够获取互斥量上的锁为止</strong>。在<code>std::lock()</code>的内部实现中，try_lock()会作为避免死锁算法的一部分。</p>
<p>列表3.8 简单的层级互斥量实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">hierarchical_mutex</span></span><br><span class="line">&#123;</span><br><span class="line">  std::mutex internal_mutex;</span><br><span class="line">  </span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> hierarchy_value;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> previous_hierarchy_value;</span><br><span class="line">  </span><br><span class="line">  <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span> this_thread_hierarchy_value;  <span class="comment">// 1</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchy_value)  <span class="comment">// 2</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    previous_hierarchy_value=this_thread_hierarchy_value;  <span class="comment">// 3</span></span><br><span class="line">    this_thread_hierarchy_value=hierarchy_value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> value)</span>:</span></span><br><span class="line"><span class="function">      hierarchy_value(value),</span></span><br><span class="line"><span class="function">      previous_hierarchy_value(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    internal_mutex.<span class="built_in">lock</span>();  <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();  <span class="comment">// 5</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    this_thread_hierarchy_value=previous_hierarchy_value;  <span class="comment">// 6</span></span><br><span class="line">    internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    <span class="keyword">if</span>(!internal_mutex.<span class="built_in">try_lock</span>())  <span class="comment">// 7</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="type">unsigned</span> <span class="type">long</span></span></span><br><span class="line"><span class="function">     <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>
<p>这里重点是使用了thread_local的值来代表当前线程的层级值：this_thread_hierarchy_value①。</p>
<p>它被初始化为最大值⑧，所以最初所有线程都能被锁住。</p>
<p>因为其声明中有thread_local，所以每个线程都有其拷贝副本，这样线程中变量状态完全独立，当从另一个线程进行读取时，变量的状态也完全独立。参见附录A，A.8节，有更多与thread_local相关的内容。</p>
<blockquote>
<p>什么是thread_local</p>
</blockquote>
<p>所以，第一次线程锁住一个hierarchical_mutex时，this_thread_hierarchy_value的值是ULONG_MAX。</p>
<p>由于其本身的性质，这个值会大于其他任何值，所以会通过check_for_hierarchy_vilation()②的检查。在这种检查方式下，lock()代表内部互斥锁已被锁住④。一旦成功锁住，你可以更新层级值了⑤。</p>
<blockquote>
<p>为什么锁住才能更新层级值？</p>
</blockquote>
<p>当你现在锁住另一个hierarchical_mutex时，还持有第一个锁，this_thread_hierarchy_value的值将会显示第一个互斥量的层级值。第二个互斥量的层级值必须小于已经持有互斥量检查函数②才能通过。</p>
<p>现在，最重要的是为当前线程存储之前的层级值，所以你可以调用unlock()⑥对层级值进行保存；</p>
<p>否则，就锁不住任何互斥量(第二个互斥量的层级数高于第一个互斥量)，即使线程没有持有任何锁。因为保存了之前的层级值，只有当持有internal_mutex③，且在解锁内部互斥量⑥之前存储它的层级值，才能安全的将hierarchical_mutex自身进行存储。这是因为hierarchical_mutex被内部互斥量的锁所保护着。</p>
<p>try_lock()与lock()的功能相似，除了在调用internal_mutex的try_lock()⑦失败时，不能持有对应锁，所以不必更新层级值，并直接返回false。</p>
<p>虽然是运行时检测，但是它没有时间依赖性——不必去等待那些导致死锁出现的罕见条件。同时，设计过程需要去拆分应用，互斥量在这样的情况下可以消除可能导致死锁的可能性。这样的设计练习很有必要去做一下，即使你之后没有去做，代码也会在运行时进行检查。</p>
<blockquote>
<p>更新线程的当前层级值是为了确保在同一线程中获取锁时遵循层次顺序，从而避免死锁。具体原因如下：</p>
<h3 id="1-确保锁的层级顺序"><a class="markdownIt-Anchor" href="#1-确保锁的层级顺序"></a> 1. 确保锁的层级顺序</h3>
<p>每个 <code>hierarchical_mutex</code> 都有一个层级值（<code>hierarchy_value</code>）。当一个线程获取一个 <code>hierarchical_mutex</code> 时，必须确保这个互斥量的层级值高于（数值上低于）当前线程已经持有的任何互斥量的层级值。这就防止了一个线程在持有低层级锁时去获取高层级锁，从而形成死锁。</p>
<h3 id="2-防止死锁"><a class="markdownIt-Anchor" href="#2-防止死锁"></a> 2. 防止死锁</h3>
<p>死锁通常发生在多个线程以不同顺序获取多个锁时。例如，如果线程 A 获取锁1，然后尝试获取锁2，同时线程 B 获取锁2，然后尝试获取锁1，就会发生死锁。通过使用层级互斥量，可以确保所有线程以一致的顺序获取锁，从而避免死锁。</p>
<h3 id="3-动态检查锁的顺序"><a class="markdownIt-Anchor" href="#3-动态检查锁的顺序"></a> 3. 动态检查锁的顺序</h3>
<p>通过在每次获取锁时更新 <code>this_thread_hierarchy_value</code>，<code>hierarchical_mutex</code> 可以动态检查线程获取锁的顺序。每次获取新锁时，都会检查当前锁的层级值是否低于（数值上高于）当前线程的层级值。如果不是，则会抛出异常。这种动态检查确保了线程不会违反层级规则，从而避免死锁。</p>
<h3 id="4-恢复之前的层级值"><a class="markdownIt-Anchor" href="#4-恢复之前的层级值"></a> 4. 恢复之前的层级值</h3>
<p>在释放锁时，将线程的层级值恢复到获取锁之前的值。这是为了确保当线程释放锁后，其层级值反映它当前持有的锁的正确状态。</p>
<h3 id="代码示例解释"><a class="markdownIt-Anchor" href="#代码示例解释"></a> 代码示例解释</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">previous_hierarchy_value = this_thread_hierarchy_value;  <span class="comment">// 保存当前线程的层级值</span></span><br><span class="line">this_thread_hierarchy_value = hierarchy_value;  <span class="comment">// 更新为当前互斥量的层级值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当一个线程获取一个  <code>hierarchical_mutex</code> 时：</p>
<ol>
<li>
<p>保存当前线程的层级值（<code>previous_hierarchy_value</code>）</p>
<p>：</p>
<ul>
<li>这一步保存了线程在获取当前互斥量之前的层级状态，以便在释放锁时可以恢复。</li>
</ul>
</li>
<li>
<p>更新线程的层级值为当前互斥量的层级值</p>
<p>：</p>
<ul>
<li>这一步确保线程在持有当前互斥量时，其层级值反映当前互斥量的层级。</li>
<li>通过这种方式，后续尝试获取的任何锁都必须具有更低（数值上更高）的层级值，否则会违反层级规则。</li>
</ul>
</li>
</ol>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>通过更新线程的当前层级值， <code>hierarchical_mutex</code> 确保了线程按照预定的层级顺序获取锁，从而有效避免了死锁的发生。这种机制在多线程编程中提供了一种结构化的方法来管理锁的顺序，确保线程之间的互斥量获取遵循严格的层级规则。</p>
</blockquote>
<p><strong>超越锁的延伸扩展</strong></p>
<p>如我在本节开头提到的那样，死锁不仅仅会发生在锁之间；</p>
<p>死锁也会发生在任何同步构造中(可能会产生一个等待循环)，因此这方面也需要有指导意见，</p>
<p><strong>例如：要去避免获取嵌套锁等待一个持有锁的线程是一个很糟糕的决定，因为线程为了能继续运行可能需要获取对应的锁。</strong></p>
<p><strong>类似的，如果去等待一个线程结束，它应该可以确定这个线程的层级，这样一个线程只需要等待比起层级低的线程结束即可。</strong></p>
<p>可以用一个简单的办法去确定，以添加的线程是否在同一函数中被启动，如同在3.1.2节和3.3节中描述的那样。</p>
<p>当代码已经能规避死锁，<code>std::lock()</code>和<code>std::lock_guard</code>能组成简单的锁覆盖大多数情况，但是有时需要更多的灵活性。</p>
<p>在这些情况，可以使用标准库提供的<code>std::unique_lock</code>模板。如<code> std::lock_guard</code>，这是一个参数化的互斥量模板类，并且它提供很多RAII类型锁用来管理<code>std::lock_guard</code>类型，可以让代码更加灵活。</p>
<h2 id="326-stdunique_lock灵活的锁"><a class="markdownIt-Anchor" href="#326-stdunique_lock灵活的锁"></a> 3.2.6 std::unique_lock——灵活的锁</h2>
<p><code>std::unqiue_lock</code>使用更为自由的不变量，这样<code>std::unique_lock</code>实例不会总与互斥量的数据类型相关，使用起来要比<code>std:lock_guard</code>更加灵活。</p>
<p>首先，可将<code>std::adopt_lock</code>作为第二个参数传入构造函数，对互斥量进行管理；</p>
<p>也可以将<code>std::defer_lock</code>作为第二个参数传递进去，表明互斥量应保持解锁状态。</p>
<p>这样，就可以被<code>std::unique_lock</code>对象(不是互斥量)的lock()函数的所获取，或传递<code>std::unique_lock</code>对象到<code>std::lock()</code>中。</p>
<p>清单3.6可以轻易的转换为清单3.9，使用<code>std::unique_lock</code>和<code>std::defer_lock</code>①，而非<code>std::lock_guard</code>和<code>std::adopt_lock</code>。</p>
<p>代码长度相同，几乎等价，唯一不同的就是：<code>std::unique_lock</code>会占用比较多的空间，并且比<code>std::lock_guard</code>稍慢一些。保证灵活性要付出代价，这个代价就是允许<code>std::unique_lock</code>实例不带互斥量：信息已被存储，且已被更新。</p>
<p>清单3.9 交换操作中<code>std::lock()</code>和<code>std::unique_lock</code>的使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class some_big_object;</span><br><span class="line">void swap(some_big_object&amp; lhs,some_big_object&amp; rhs);</span><br><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line">public:</span><br><span class="line">  X(some_big_object const&amp; sd):some_detail(sd)&#123;&#125;</span><br><span class="line">  friend void swap(X&amp; lhs, X&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    if(&amp;lhs==&amp;rhs)</span><br><span class="line">      return;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock_a(lhs.m,std::defer_lock); // 1 </span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock_b(rhs.m,std::defer_lock); // 1 std::def_lock 留下未上锁的互斥量</span><br><span class="line">    std::lock(lock_a,lock_b); // 2 互斥量在这里上锁</span><br><span class="line">    swap(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>列表3.9中，因为<code>std::unique_lock</code>支持lock(), try_lock()和unlock()成员函数，**所以能将<code>std::unique_lock</code>对象传递到<code>std::lock()</code>**②。这些同名的成员函数在低层做着实际的工作，并且仅更新<code>std::unique_lock</code>实例中的标志，来确定该实例是否拥有特定的互斥量，这个标志是为了确保unlock()在析构函数中被正确调用。如果实例拥有互斥量，那么析构函数必须调用unlock()；但当实例中没有互斥量时，析构函数就不能去调用unlock()。这个标志可以通过owns_lock()成员变量进行查询。</p>
<p>可能如你期望的那样，这个标志被存储在某个地方。因此，<code>std::unique_lock</code>对象的体积通常要比<code>std::lock_guard</code>对象大，当使用<code>std::unique_lock</code>替代<code>std::lock_guard</code>，因为会对标志进行适当的更新或检查，就会做些轻微的性能惩罚。</p>
<p>当<code>std::lock_guard</code>已经能够满足你的需求，那么还是建议你继续使用它。当需要更加灵活的锁时，最好选择<code>std::unique_lock</code>，因为它更适合于你的任务。你已经看到一个递延锁的例子，另外一种情况是锁的所有权需要从一个域转到另一个域。</p>
<h2 id="327-不同域中互斥量所有权的传递"><a class="markdownIt-Anchor" href="#327-不同域中互斥量所有权的传递"></a> 3.2.7 不同域中互斥量所有权的传递</h2>
<p><code>std::unique_lock</code>实例没有与自身相关的互斥量，一个互斥量的所有权可以通过移动操作，在不同的实例中进行传递。某些情况下，这种转移是自动发生的，例如:当函数返回一个实例；另些情况下，需要显式的调用<code>std::move()</code>来执行移动操作。从本质上来说，需要依赖于源值是否是左值——一个实际的值或是引用——或一个右值——一个临时类型。当源值是一个右值，为了避免转移所有权过程出错，就必须显式移动成左值。<code>std::unique_lock</code>是可移动，但不可赋值的类型。附录A，A.1.1节有更多与移动语句相关的信息。</p>
<p>一种使用可能是允许一个函数去锁住一个互斥量，并且将所有权移到调用者上，所以调用者可以在这个锁保护的范围内执行额外的动作。</p>
<p>下面的程序片段展示了：函数get_lock()锁住了互斥量，然后准备数据，返回锁的调用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::unique_lock&lt;std::mutex&gt; get_lock()</span><br><span class="line">&#123;</span><br><span class="line">  extern std::mutex some_mutex;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lk(some_mutex);</span><br><span class="line">  prepare_data();</span><br><span class="line">  return lk;  // 1</span><br><span class="line">&#125;</span><br><span class="line">void process_data()</span><br><span class="line">&#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lk(get_lock());  // 2</span><br><span class="line">  do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lk在函数中被声明为自动变量，它不需要调用<code>std::move()</code>，可以直接返回①(编译器负责调用移动构造函数)。process_data()函数直接转移<code>std::unique_lock</code>实例的所有权②，调用do_something()可使用的正确数据(数据没有受到其他线程的修改)。</p>
<p>通常这种模式会用于已锁的互斥量，其依赖于当前程序的状态，或依赖于传入返回类型为<code>std::unique_lock</code>的函数(或以参数返回)。这样的用法不会直接返回锁，不过网关类的一个数据成员可用来确认已经对保护数据的访问权限进行上锁。这种情况下，所有的访问都必须通过网关类：当你想要访问数据，需要获取网关类的实例(如同前面的例子，通过调用get_lock()之类函数)来获取锁。之后你就可以通过网关类的成员函数对数据进行访问。当完成访问，可以销毁这个网关类对象，将锁进行释放，让别的线程来访问保护数据。这样的一个网关类可能是可移动的(所以他可以从一个函数进行返回)，在这种情况下锁对象的数据必须是可移动的。</p>
<p><code>std::unique_lock</code>的灵活性同样也允许实例在销毁之前放弃其拥有的锁。可以使用unlock()来做这件事，如同一个互斥量：<code>std::unique_lock</code>的成员函数提供类似于锁定和解锁互斥量的功能。<code>std::unique_lock</code>实例在销毁前释放锁的能力，当锁没有必要在持有的时候，可以在特定的代码分支对其进行选择性的释放。这对于应用性能来说很重要，因为持有锁的时间增加会导致性能下降，其他线程会等待这个锁的释放，避免超越操作。</p>
<h2 id="328-锁的粒度"><a class="markdownIt-Anchor" href="#328-锁的粒度"></a> 3.2.8 锁的粒度</h2>
<p>3.2.3节中，已经对锁的粒度有所了解：锁的粒度是一个<em>摆手术语</em>(hand-waving term)，<strong>用来描述通过一个锁保护着的数据量大小</strong>。</p>
<p><em>一个细粒度锁</em>(a fine-grained lock)能够保护较小的数据量，<em>一个粗粒度锁</em>(a coarse-grained lock)能够保护较多的数据量。选择粒度对于锁来说很重要，为了保护对应的数据，保证锁有能力保护这些数据也很重要。我们都知道，在超市等待结账的时候，正在结账的顾客突然意识到他忘了拿蔓越莓酱，然后离开柜台去拿，并让其他的人都等待他回来；或者当收银员，准备收钱时，顾客才去翻钱包拿钱，这样的情况都会让等待的顾客很无奈。当每个人都检查了自己要拿的东西，且能随时为拿到的商品进行支付，那么的每件事都会进行的很顺利。</p>
<p>这样的道理同样适用于线程：</p>
<p>如果很多线程正在等待同一个资源(等待收银员对自己拿到的商品进行清点)，当有线程持有锁的时间过长，这就会增加等待的时间(别等到结账的时候，才想起来蔓越莓酱没拿)。在可能的情况下，锁住互斥量的同时只能对共享数据进行访问；试图对锁外数据进行处理。</p>
<p>特别是做一些费时的动作，比如：对文件的输入/输出操作进行上锁。文件输入/输出通常要比从内存中读或写同样长度的数据慢成百上千倍，所以除非锁已经打算去保护对文件的访问，要么执行输入/输出操作将会将延迟其他线程执行的时间，这很没有必要(因为文件锁阻塞住了很多操作)，这样多线程带来的性能效益会被抵消。</p>
<p><code>std::unique_lock</code>在这种情况下工作正常，在调用unlock()时，代码不需要再访问共享数据；而后当再次需要对共享数据进行访问时，就可以再调用lock()了。下面代码就是这样的一种情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void get_and_process_data()</span><br><span class="line">&#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; my_lock(the_mutex);</span><br><span class="line">  some_class data_to_process=get_next_data_chunk();</span><br><span class="line">  my_lock.unlock();  // 1 不要让锁住的互斥量越过process()函数的调用</span><br><span class="line">  result_type result=process(data_to_process);</span><br><span class="line">  my_lock.lock(); // 2 为了写入数据，对互斥量再次上锁</span><br><span class="line">  write_result(data_to_process,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不需要让锁住的互斥量越过对process()函数的调用，所以可以在函数调用①前对互斥量手动解锁，并且在之后对其再次上锁②。</p>
<p>这能表示只有一个互斥量保护整个数据结构时的情况，不仅可能会有更多对锁的竞争，也会增加锁持锁的时间。较多的操作步骤需要获取同一个互斥量上的锁，所以持有锁的时间会更长。成本上的双重打击也算是为向细粒度锁转移提供了双重激励和可能。</p>
<p><strong>如同上面的例子，锁不仅是能锁住合适粒度的数据，还要控制锁的持有时间，以及什么操作在执行的同时能够拥有锁。一般情况下，执行必要的操作时，尽可能将持有锁的时间缩减到最小。</strong></p>
<p>这也就意味有一些浪费时间的操作，比如：获取另外一个锁(即使你知道这不会造成死锁)，或等待输入/输出操作完成时没有必要持有一个锁(除非绝对需要)。</p>
<p>清单3.6和3.9中，交换操作需要锁住两个互斥量，其明确要求并发访问两个对象。假设用来做比较的是一个简单的数据类型(比如:int类型)，将会有什么不同么？int的拷贝很廉价，所以可以很容易的进行数据复制，并且每个被比较的对象都持有该对象的锁，在比较之后进行数据拷贝。这就意味着，在最短时间内持有每个互斥量，并且你不会在持有一个锁的同时再去获取另一个。下面的清单中展示了一个在这样情景中的Y类，并且展示了一个相等比较运算符的等价实现。</p>
<p>列表3.10 比较操作符中一次锁住一个互斥量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Y</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">  int some_detail;</span><br><span class="line">  mutable std::mutex m;</span><br><span class="line">  int get_detail() const</span><br><span class="line">  &#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock_a(m);  // 1</span><br><span class="line">    return some_detail;</span><br><span class="line">  &#125;</span><br><span class="line">public:</span><br><span class="line">  Y(int sd):some_detail(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  friend bool operator==(Y const&amp; lhs, Y const&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    if(&amp;lhs==&amp;rhs)</span><br><span class="line">      return true;</span><br><span class="line">    int const lhs_value=lhs.get_detail();  // 2</span><br><span class="line">    int const rhs_value=rhs.get_detail();  // 3</span><br><span class="line">    return lhs_value==rhs_value;  // 4</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，比较操作符首先通过调用get_detail()成员函数检索要比较的值②③，函数在索引值时被一个锁保护着①。比较操作符会在之后比较索引出来的值④。注意：虽然这样能减少锁持有的时间，一个锁只持有一次(这样能消除死锁的可能性)，这里有一个微妙的语义操作同时对两个锁住的值进行比较。</p>
<p>列表3.10中，当操作符返回true时，那就意味着在这个时间点上的lhs.some_detail与在另一个时间点的rhs.some_detail相同。这两个值在读取之后，可能会被任意的方式所修改；两个值会在②和③处进行交换，这样就会失去比较的意义。等价比较可能会返回true，来表明这两个值时相等的，实际上这两个值相等的情况可能就发生在一瞬间。这样的变化要小心，语义操作是无法改变一个问题的比较方式：当你持有锁的时间没有达到整个操作时间，就会让自己处于条件竞争的状态。</p>
<p><strong>有时，只是没有一个合适粒度级别，因为并不是所有对数据结构的访问都需要同一级的保护。这个例子中，就需要寻找一个合适的机制，去替换<code>std::mutex</code>。</strong></p>
<hr />
<p>[1] Tom Cargill, “Exception Handling: A False Sense of Security,” in C++ Report 6, no. 9 (November–December 1994). Also available at <a class="link"   target="_blank" rel="noopener" href="http://www.informit.com/content/images/020163371x/supplements/Exception_Handling_Article.html" >http://www.informit.com/content/images/020163371x/supplements/Exception_Handling_Article.html<i class="fas fa-external-link-alt"></i></a>.</p>
<p>[2] Herb Sutter, Exceptional C++: 47 Engineering Puzzles, Programming Problems, and Solutions (Addison Wesley Pro-fessional, 1999).</p>

                </div>
                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/06/20/20240620-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%89%EF%BC%89/"
                                   title="20240620 C++并发编程实战（三）"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">20240620 C++并发编程实战（三）</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/06/20/20240620-%E5%88%A9%E7%94%A8%E9%A2%9D%E5%A4%96%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%80%86%E5%BA%8F/"
                                   title="20240620 算法:利用额外栈实现逆序"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">20240620 算法:利用额外栈实现逆序</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">评论插件加载失败</span>
    <button class="reload keep-button">点击重新加载</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">正在加载评论插件</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="valine-container">
        <div id="vcomments"></div>
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        ></script>
        <script 
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        >
          window.KeepCommentPlugin.initValine = () => {
            const config = {
              el: '#vcomments',
              appId: 'DYpeXIX0A58ayXv2jFns418I-gzGzoHsz',
              appKey: 'aVeRlE1OlBTUKleFs6ZKOrga',
              meta: ['nick', 'mail', 'link'],
              avatar: 'wavatar',
              enableQQ: true,
              placeholder: '╲╱__ ╭の╮ ┈不管结局如何ヾ 是否完美゛ .我都不会放弃!',
              lang: 'zh-Hans'.toLowerCase()
            }

            if ('') {
              config.serverURLs = ''
            }

            if (window?.Valine) {
              new Valine(config)
              window.KeepCommentPlugin.hideLoading()
            } else {
              setTimeout(() => {
                window.KeepCommentPlugin.initValine()
              }, 1000)
            }
          }

          if ('false' === 'true') {
            setTimeout(() => {
              window.KeepCommentPlugin.initValine()
            }, 1200)
          } else {
            window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initValine)
          }
        </script>
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#32-%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">1.</span> <span class="nav-text"> 3.2 使用互斥量保护共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#321-c%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text"> 3.2.1 C++中使用互斥量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322-%E7%B2%BE%E5%BF%83%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%E6%9D%A5%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.</span> <span class="nav-text"> 3.2.2 精心组织代码来保护共享数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#323-%E5%8F%91%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%86%85%E5%9C%A8%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89"><span class="nav-number">1.3.</span> <span class="nav-text"> 3.2.3 发现接口内在的条件竞争</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#324-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.4.</span> <span class="nav-text"> 3.2.4 死锁：问题描述及解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#325-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%9A%84%E8%BF%9B%E9%98%B6%E6%8C%87%E5%AF%BC"><span class="nav-number">1.5.</span> <span class="nav-text"> 3.2.5 避免死锁的进阶指导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A1%AE%E4%BF%9D%E9%94%81%E7%9A%84%E5%B1%82%E7%BA%A7%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 1. 确保锁的层级顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%98%B2%E6%AD%A2%E6%AD%BB%E9%94%81"><span class="nav-number">1.5.2.</span> <span class="nav-text"> 2. 防止死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8A%A8%E6%80%81%E6%A3%80%E6%9F%A5%E9%94%81%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.5.3.</span> <span class="nav-text"> 3. 动态检查锁的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%81%A2%E5%A4%8D%E4%B9%8B%E5%89%8D%E7%9A%84%E5%B1%82%E7%BA%A7%E5%80%BC"><span class="nav-number">1.5.4.</span> <span class="nav-text"> 4. 恢复之前的层级值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8A"><span class="nav-number">1.5.5.</span> <span class="nav-text"> 代码示例解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.6.</span> <span class="nav-text"> 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#326-stdunique_lock%E7%81%B5%E6%B4%BB%E7%9A%84%E9%94%81"><span class="nav-number">1.6.</span> <span class="nav-text"> 3.2.6 std::unique_lock——灵活的锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#327-%E4%B8%8D%E5%90%8C%E5%9F%9F%E4%B8%AD%E4%BA%92%E6%96%A5%E9%87%8F%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-number">1.7.</span> <span class="nav-text"> 3.2.7 不同域中互斥量所有权的传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#328-%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="nav-number">1.8.</span> <span class="nav-text"> 3.2.8 锁的粒度</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2025
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">明昧</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#32-%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">1.</span> <span class="nav-text"> 3.2 使用互斥量保护共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#321-c%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text"> 3.2.1 C++中使用互斥量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322-%E7%B2%BE%E5%BF%83%E7%BB%84%E7%BB%87%E4%BB%A3%E7%A0%81%E6%9D%A5%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE"><span class="nav-number">1.2.</span> <span class="nav-text"> 3.2.2 精心组织代码来保护共享数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#323-%E5%8F%91%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%86%85%E5%9C%A8%E7%9A%84%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89"><span class="nav-number">1.3.</span> <span class="nav-text"> 3.2.3 发现接口内在的条件竞争</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#324-%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.4.</span> <span class="nav-text"> 3.2.4 死锁：问题描述及解决方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#325-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%9A%84%E8%BF%9B%E9%98%B6%E6%8C%87%E5%AF%BC"><span class="nav-number">1.5.</span> <span class="nav-text"> 3.2.5 避免死锁的进阶指导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A1%AE%E4%BF%9D%E9%94%81%E7%9A%84%E5%B1%82%E7%BA%A7%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.5.1.</span> <span class="nav-text"> 1. 确保锁的层级顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%98%B2%E6%AD%A2%E6%AD%BB%E9%94%81"><span class="nav-number">1.5.2.</span> <span class="nav-text"> 2. 防止死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8A%A8%E6%80%81%E6%A3%80%E6%9F%A5%E9%94%81%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.5.3.</span> <span class="nav-text"> 3. 动态检查锁的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%81%A2%E5%A4%8D%E4%B9%8B%E5%89%8D%E7%9A%84%E5%B1%82%E7%BA%A7%E5%80%BC"><span class="nav-number">1.5.4.</span> <span class="nav-text"> 4. 恢复之前的层级值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E8%A7%A3%E9%87%8A"><span class="nav-number">1.5.5.</span> <span class="nav-text"> 代码示例解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.5.6.</span> <span class="nav-text"> 总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#326-stdunique_lock%E7%81%B5%E6%B4%BB%E7%9A%84%E9%94%81"><span class="nav-number">1.6.</span> <span class="nav-text"> 3.2.6 std::unique_lock——灵活的锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#327-%E4%B8%8D%E5%90%8C%E5%9F%9F%E4%B8%AD%E4%BA%92%E6%96%A5%E9%87%8F%E6%89%80%E6%9C%89%E6%9D%83%E7%9A%84%E4%BC%A0%E9%80%92"><span class="nav-number">1.7.</span> <span class="nav-text"> 3.2.7 不同域中互斥量所有权的传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#328-%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="nav-number">1.8.</span> <span class="nav-text"> 3.2.8 锁的粒度</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->


<!-- lazyload -->


<div class="">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
