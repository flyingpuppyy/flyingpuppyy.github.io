<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="明昧">
    
    <title>
        
            20240622 C++面试八股 |
        
        行者无畏
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"flyingpuppyy.github.io","root":"/","language":"zh-Hans"}
    KEEP.theme_config = {"base_info":{"primary_color":"#FA8072","title":"行者无畏","author":"明昧","avatar":"/images/tou.jpeg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives","categories":"/categories"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"没有一条路径通往真诚 真诚本身就是道路","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":false,"preload":false},"comment":{"enable":true,"use":"valine","valine":{"appid":"DYpeXIX0A58ayXv2jFns418I-gzGzoHsz","appkey":"aVeRlE1OlBTUKleFs6ZKOrga","server_urls":null,"placeholder":"请在此输入您的留言"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":false,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"encrypt":{"enable":true},"root":"","source_data":{},"version":"4.1.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               行者无畏
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                HOME
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                ARCHIVES
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                
                                CATEGORIES
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >HOME</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >ARCHIVES</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >CATEGORIES</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        20240622 C++面试八股
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/tou.jpeg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">明昧</span>
                                
                                    <span class="author-badge">Lv6</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-06-22 18:25:00</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Sun Jun 30 2024 17:34:09 GMT+0800">2024-06-30 17:34:09</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li>
                        
                    
                </ul>
            </span>
        

        

        
        
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<ul>
<li>这个题库里几乎所有东西你都你能看懂，对于面试来说，最重要的就是复述！带有自己逻辑和框架的复述！</li>
</ul>
<h1 id="c11新特性"><a class="markdownIt-Anchor" href="#c11新特性"></a> C++11新特性</h1>
<h2 id="30-unique_ptr和shared_ptr的区别是什么"><a class="markdownIt-Anchor" href="#30-unique_ptr和shared_ptr的区别是什么"></a> 30、unique_ptr和shared_ptr的区别是什么</h2>
<p>uptr指向的对象只能有一个uptr指针作为访问入口</p>
<p>sptr指向的对象可以有多个sptr指向同一个对象作为访问入口</p>
<hr />
<p>两者都能实现内存的自动管理与释放</p>
<h2 id="shared_ptr是线程安全的吗"><a class="markdownIt-Anchor" href="#shared_ptr是线程安全的吗"></a> shared_ptr是线程安全的吗</h2>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/56836057" >https://www.zhihu.com/question/56836057<i class="fas fa-external-link-alt"></i></a></p>
<ul>
<li>线程安全：线程的操作都按照预期执行。如果多线程环境下代码运行的结果是符合我们预期的，即在单线程环境应该的结果，则说这个程序是线程安全的。</li>
<li>谈到sptr的时候，要分不同的操作对象和操作行为来讨论其线程安全性</li>
</ul>
<blockquote>
<p>1.shareptr引用记数的行为（是线程安全的，因为源码是原子操作）</p>
<p>2.shareptr们修改指针指向的行为是线程安全的吗？</p>
<blockquote>
<p>修改也分几种情况</p>
<p>修改有的是将该指针变为空指针</p>
<p>有的情况的将该指针指向对象改变</p>
</blockquote>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240622193609122.png"  alt="image-20240622193609122" ></p>
<p>3.所管理数据的线程安全性（不是线程安全的，</p>
<blockquote>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240622193840841.png"  alt="image-20240622193840841" ></p>
</blockquote>
</blockquote>
<hr />
<p>不行，我的探索欲望上来了</p>
<p>引用计数改变我们一般是在什么情况下改变，那么多个对象，这么多个线程，难道我们需要通过一张庞大的线程的对照表来对来查找并且维护对于相关对象的引用计数吗？</p>
<p>明确引用技术是在什么函数被调用的情况下实现的？</p>
<p>我们明确知道引用技术的修改和实际的指向修改肯定不是同一条语句</p>
<p>在我们通过变量修改指向的时候，如果不是整个过程实现原子操作，很容易出问题</p>
<p>可能执行上一条之后这个变量应该被销毁了（记数层面来看被销毁了）</p>
<h2 id="1-c11引入了哪些新的指针类型简单描述一下它们的作用"><a class="markdownIt-Anchor" href="#1-c11引入了哪些新的指针类型简单描述一下它们的作用"></a> 1、C++11引入了哪些新的指针类型？简单描述一下它们的作用*</h2>
<blockquote>
<p>引入了s u w</p>
<p>s</p>
<p>u</p>
<p>w  弱引用：不增加引用计数，不影响对象的生命周期。</p>
<blockquote>
<p>还是不太懂w会被用在哪里</p>
</blockquote>
</blockquote>
<h2 id="c11中的右值引用与移动语义是怎样提高性能的"><a class="markdownIt-Anchor" href="#c11中的右值引用与移动语义是怎样提高性能的"></a> C++11中的右值引用与移动语义是怎样提高性能的</h2>
<ul>
<li>
<p>右值引用：通过 <code>&amp;&amp;</code> 实现，允许对临时对象进行引用。</p>
</li>
<li>
<p>在对象的传递和返回操作中。<strong>通过减少不必要的拷贝操作</strong>，右值引用和移动语义可以显著提升效率。</p>
</li>
<li>
<p>移动语义：允许资源从一个对象“移动”到另一个对象，而不是复制资源。这对于涉及动态内存、文件句柄等资源的对象非常有用，因为移动操作可以显著减少资源管理的开销。</p>
</li>
<li>
<p>实现所需步骤：自己实现移动构造函数和移动赋值运算符</p>
</li>
</ul>
<h2 id="c11中右值左值相互转换的问题"><a class="markdownIt-Anchor" href="#c11中右值左值相互转换的问题"></a> C11中右值左值相互转换的问题*</h2>
<p><strong>左值可以隐式转换成右值</strong>：当左值在需要右值的地方使用时，编译器会自动完成这种转换。</p>
<p><strong>右值不能直接转换成左值</strong>：右值是临时对象，不能直接转换成左值。但可以通过右值引用或 <code>const</code> 左值引用来间接地将右值绑定为左值，从而在需要时操作或读取它。</p>
<blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manipulateRvalue</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">20</span>; <span class="comment">// x 是一个右值引用，但在函数体内它被视为左值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">manipulateRvalue</span>(<span class="number">10</span>); <span class="comment">// 10 是右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printRvalue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printRvalue</span>(<span class="number">10</span>); <span class="comment">// 10 是右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="3-c请你谈谈对auto关键字的理解并且谈谈在实际应用中它的作用"><a class="markdownIt-Anchor" href="#3-c请你谈谈对auto关键字的理解并且谈谈在实际应用中它的作用"></a> 3、C++请你谈谈对auto关键字的理解,并且谈谈在实际应用中它的作用</h2>
<ul>
<li>使用 <code>auto</code> 关键字时，你不需要显式地指定变量的类型，编译器会根据变量的初始化表达式来推断其类型。</li>
<li><code>auto</code> 可以用于局部变量、函数参数、返回类型等场景。</li>
</ul>
<ul>
<li>类型推断推断变量的类型。</li>
<li>在泛型编程中，当类型参数非常复杂或者难以显式指定时用</li>
</ul>
<h2 id="4-c11中lambda表达式是什么如何使用它们"><a class="markdownIt-Anchor" href="#4-c11中lambda表达式是什么如何使用它们"></a> 4 、C++11中lambda表达式是什么，如何使用它们</h2>
<blockquote>
<p>是一个<s>不用声明</s>**（匿名）**的函数区块或者是说是函数对象</p>
<hr />
<p>使用</p>
<p><a href=""></a>{}</p>
<p>[=] 按值捕获</p>
<p>[x]</p>
<p>​	[&amp;]按引用捕获</p>
</blockquote>
<h1 id="c内存"><a class="markdownIt-Anchor" href="#c内存"></a> C++内存</h1>
<h2 id="全局变量和静态变量的区别"><a class="markdownIt-Anchor" href="#全局变量和静态变量的区别"></a> 全局变量和静态变量的区别</h2>
<h2 id="栈和堆的区别是什么"><a class="markdownIt-Anchor" href="#栈和堆的区别是什么"></a> 栈和堆的区别是什么</h2>
<ul>
<li>全局区(静态区)(static):全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另外一块区域。程序结束后由系统释放。</li>
</ul>
<h3 id="栈区stack"><a class="markdownIt-Anchor" href="#栈区stack"></a> 栈区（stack）</h3>
<ul>
<li>问地址分配就说高低（<strong>其实架构不同不一定遵守这个分配规则</strong>）</li>
<li>存放程序的局部变量，在函数被调用时，栈用来传递参数和返回值</li>
</ul>
<ul>
<li>
<p>先进后出，一旦出了作用域就会被销毁</p>
</li>
<li>
<p>编译器自动管理内存</p>
</li>
</ul>
<h3 id="堆区heap"><a class="markdownIt-Anchor" href="#堆区heap"></a> 堆区（heap）</h3>
<p>堆是用于存放进程运行中被<strong>动态分配的内存段</strong>，它的大小并不固定，可动态扩张或缩减。当进程调用malloc/free等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)/释放的内存从堆中被剔除(堆被缩减)。</p>
<ul>
<li>问地址分配就说低高</li>
</ul>
<ul>
<li>堆区的内存分配使用的是alloc；</li>
<li>需要程序员管理内存</li>
</ul>
<h2 id="3-内存泄漏的场景有哪些"><a class="markdownIt-Anchor" href="#3-内存泄漏的场景有哪些"></a> 3、内存泄漏的场景有哪些</h2>
<blockquote>
<p>场景和概念的层次可能会有重合，总之列出123456就可以了</p>
<p>1.申请与释放没有成对出现</p>
<p>2.类的设计中具有指针，但是析构函数没有实现释放</p>
<p>3.浅拷贝带来的析构函数两次释放问题</p>
<p>4.设计类中自身给自身赋值或者自己给自己拷贝的自身检查</p>
<p>5.返回局部指针</p>
<p>6.子类父类析构函数缺少虚继承关系</p>
<p>（<strong>利用基类指针进行子类对象释放的适合，如果不是这样定义，可能会导致子类对象有部分数据内存未被释放</strong>）</p>
</blockquote>
<blockquote>
<hr />
<p>1、利用malloc申请内存，没有释放或者释放不正确对象占用的内存</p>
<p>2.<strong>构造函数</strong>中分配内存，<strong>析构</strong>中没有…<mark>(1的特化)</mark></p>
<blockquote>
<p>判断设计正确不正确的思路：</p>
<p>malloc/free   new/delete必须成对出现</p>
<p>数组对象必须采取[ ]进行析构</p>
<p>指针数组对象除了对数组本身指针析构，还得析构指针所指向的空间</p>
</blockquote>
<blockquote>
<p><strong>方括号与内存释放</strong></p>
<p>方括号存在的作用：</p>
<p>1.告诉编译器这个<strong>指针指向</strong>的是一个对象<strong>数组</strong>，</p>
<p>2.同时也<strong>告诉</strong>编译器正确的<strong>对象地址值</strong>并调用对象的析构函数，</p>
<p>如果没有方括号，那么这个指针就被默认为只指向一个对象，</p>
<p>对象数组中的其他对象的析构函数就不会被调用，结果造成了内存泄露。</p>
<hr />
<p>如果在<strong>方括号中间放了一个比对象数组大小还大的数字</strong>/<strong>释放过大空间</strong>，</p>
<p>那么编译器就会调用无效对象（内存溢出）的析构函数，会造成堆的奔溃。</p>
<p>如果方括号<strong>中间的数字值比对象数组的大小小的话</strong>/<strong>释放空间不到位</strong>，</p>
<p>编译器就不能调用足够多个析构函数，结果会造成内存泄露。</p>
<hr />
<p>1&gt;对于单个对象，单个基本类型（如int，double等）的变量，我们肯定採用delete，不会出错；</p>
<p>2&gt;对于基本类型数组，因为不须要大小參数，因而，採用delete或array delete（delete []），均能够，如上例中，我便直接採用了delete m_variety,建议为了统一，採用delete []m_variety;</p>
<p>3&gt;对于自己定义的对象所组成的对象数组，则一定要採用array delete,这样编译器才会在释放内存前调用每一个对象的析构函数，并调用free释放对象数组空间；</p>
<p><strong>4、指向对象的指针数组不等同于对象数组</strong></p>
</blockquote>
<p>对象数组是指：数组中存放的是对象，只需要delete []p，即可调用对象数组中的每个对象的析构函数释放空间</p>
<p>指向对象的指针数组是指：数组中存放的是指向对象的指针，不仅要释放每个对象的空间，还要释放每个指针的空间，delete []p只是释放了每个指针，但是并没有释放对象的空间，正确的做法，是通过一个循环，将每个对象释放了，然后再把指针释放了。</p>
<p>也就是说，数组的基本类型是指向对象的指针,此时，是用delete 还是delete [](array delete),并不重要，关键是指针并没有析构函数，必须用户自己调用delete语句。</p>
<p>5、缺少拷贝构造函数</p>
<p>两次释放相同的内存是一种错误的做法，同时可能会造成堆的奔溃。</p>
<p>按值传递会调用（拷贝）构造函数，引用传递不会调用。</p>
<p>在C++中，如果没有定义拷贝构造函数，那么编译器就会调用默认的拷贝构造函数，会逐个成员拷贝的方式来复制数据成员（位拷贝），如果是以逐个成员拷贝的方式来复制指针被定义为将一个变量的地址赋给另一个变量。这种隐式的指针复制结果就是两个对象拥有指向同一个动态分配的内存空间的指针。</p>
<p>当释放第一个对象的时候，它的析构函数就会释放与该对象有关的动态分配的内存空间。而释放第二个对象的时候，它的析构函数会释放相同的内存，这样是错误的。</p>
<p>所以，如果一个类里面有指针成员变量，要么必须显示的写拷贝构造函数和重载赋值运算符，要么禁用拷贝构造函数和重载赋值运算符。</p>
<ol start="6">
<li>缺少重载赋值运算符</li>
</ol>
<p>这种问题跟上述问题类似，也是逐个成员拷贝的方式复制对象，如果这个类的大小是可变的，那么结果就是造成内存泄露。</p>
<p>须要注意事实上现的细节差别：</p>
<blockquote>
<p>1&gt; 拷贝构造函数编译器会自己主动阻止自己构造自己,比方：</p>
<p>Point x(x); // 出错;</p>
<p>可是，赋值操作不会;</p>
<p>Point x = x; // 编译期不会出错，但执行期会出错!</p>
<p>上面的错误原因在于，编译器尽管为x分配了内存，但调用拷贝构造函数时，m_color还没初始化;</p>
<p>建议，尽量不要用这样的方法初始化,以便将错误在编译期间显示出来;</p>
<p>2&gt; 赋值运算符必须差别是否自身赋值;</p>
<p>3&gt; 在赋值前必须释放原有new操作分配的资源(当然，其它文件等资源也要释放，这里仅仅讨论内存溢出，略过不提！)</p>
</blockquote>
<p>7.返回值为野指针</p>
<p>a. 返回栈上对象的引用或者指针（也即返回局部对象的引用或者指针）。导致最后返回的是一个空引用或者空指针，因此变成野指针</p>
<p>b. 返回内部静态对象的引用。</p>
<p>c. 返回一个泄露内存的动态分配的对象。导致内存泄露，并且无法回收</p>
<p>解决这一类问题的办法是重载运算符函数的返回值不是类型的引用，二应该是类型的返回值，即不是 int&amp;而是int</p>
<p>8.没用将基类的析构函数定义成虚函数</p>
<p>1&gt; 将基类构造函数定义为非虚函数，则该类不同意扩展;</p>
<p>2&gt; 假设不是虚函数，则释放基类指针不会调用派生类的析构函数，即使它指向一个派生类对象;</p>
<p>3&gt; 无论是不是虚函数，释放派生类指针均会调用基类的析构函数，且调用顺序不变;</p>
<p>4&gt; 假设为虚函数，则释放基类指针且该指针指向一个派生类，则会先调用派生类的析构函数，再调用基类的析构函数。<br />
————————————————</p>
<pre><code>                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
</code></pre>
<p>原文链接：<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/dddgggd/article/details/119007585" >https://blog.csdn.net/dddgggd/article/details/119007585<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="4-内存分配的方式有多少种"><a class="markdownIt-Anchor" href="#4-内存分配的方式有多少种"></a> 4、内存分配的方式有多少种</h2>
<h3 id="从静态存储区分配内存"><a class="markdownIt-Anchor" href="#从静态存储区分配内存"></a> 从静态存储区分配内存</h3>
<p>从静态存储区域分配的内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。静态分配的区域的生命期是整个软件运行期，就是说从软件运行开始到软件终止退出。只有软件终止运行后，这块内存才会被系统回收。</p>
<h3 id="从栈上分配内存"><a class="markdownIt-Anchor" href="#从栈上分配内存"></a> 从栈上分配内存</h3>
<p><mark>在执行函数时</mark>，<strong>函数内局部变量的存储单元</strong>都可以在栈上创建，<strong>函数执行结束时这些存储单元自动被释放</strong>。栈内存分配运算内置于处理器的指令集中，效率很高，但  是分配的内存容量有限。在栈中分配的空间的生命期与这个变量所在的函数和类相关。如果是函数中定义的局部变量，那么它的生命期就是函数被调用时，如果函数运行结束，那么这块内存就会被回收。如果是类中的成员变量，则它的生命期与类实例的生命期相同。</p>
<blockquote>
<p>理解：系统自动分配，如声明int a;系统自动在栈空间中为a开辟空间。</p>
</blockquote>
<h3 id="从堆上分配内存"><a class="markdownIt-Anchor" href="#从堆上分配内存"></a> 从堆上分配内存</h3>
<p>亦称<strong>动态内存分配</strong>。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存  期由我们决定，使用非常灵活，但问题也最多。在堆上分配的内存，生命期是从调用new或者malloc开始，到调用delete或者free结束。如果不 掉用delete或者free。则这块空间必须到软件运行结束后才能被系统回收。</p>
<blockquote>
<p>理解：程序员申请，并指明大小<br />
c中的malloc，如char<em>p=(char</em>)malloc(10);<br />
C++中的new运算符：如int*p2=new int(10);</p>
</blockquote>
<h2 id="5-静态内存分配和动态内存分配的区别"><a class="markdownIt-Anchor" href="#5-静态内存分配和动态内存分配的区别"></a> 5、静态内存分配和动态内存分配的区别</h2>
<ul>
<li>
<p>从几个层面描述区别</p>
<blockquote>
<p>谁来操作</p>
<p>特点：动静</p>
<p>内存区域：</p>
<p>内存申请时机</p>
<p>内存释放时机</p>
<p>内存使用时机</p>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>编译时、静态、   、程序全程、程序运行前、编译器</li>
<li>运行时、动态、堆、程序运行时，程序运行时、用户动态申请</li>
</ul>
</blockquote>
<h2 id="6-什么是内存泄漏如何避免它"><a class="markdownIt-Anchor" href="#6-什么是内存泄漏如何避免它"></a> 6、什么是内存泄漏？如何避免它？</h2>
<p>​	被申请但是内存没有被正确释放的情况（忘记释放，释放过少，失去控制入口（没有接受、或者是切换时没有释放或者存储））</p>
<blockquote>
<p>确保没有在访问空指针</p>
<p>每个内存分配函数都应该有一个 free 函数与之对应，alloc 函数除外。</p>
<p>每次分配内存之后都应该及时进行<strong>初始化</strong>，可以结合 memset 函数进行初始化，calloc 函数除外。</p>
<p>每当向指针写入值时，都要确保对<strong>可用</strong>字节数和<strong>所写入的字节数</strong>进行交叉核对。</p>
<p><strong>在对指针赋值前，一定要确保没有内存位置会变为孤立的。</strong></p>
<p>每当释放<strong>结构化的元素</strong>（而该元素又包含指向动态分配的内存位置的指针）时，都应先遍历子内存位置并从那里开始释放，然后再遍历回父节点。</p>
<p>始终正确处理<strong>返回动态分配的内存引用</strong>的函数返回值。<br />
————————————————</p>
<pre><code>                     版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
</code></pre>
<p>原文链接：<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44718794/article/details/107071169" >https://blog.csdn.net/weixin_44718794/article/details/107071169<i class="fas fa-external-link-alt"></i></a></p>
<hr />
<h2 id="内存泄露检测工具valgrind"><a class="markdownIt-Anchor" href="#内存泄露检测工具valgrind"></a> 内存泄露检测工具valgrind</h2>
<p>这是一个linux下的内存泄露检测工具</p>
<blockquote>
<p>这个工具检查valgrind的原理是什么</p>
<p>memcheck实现了一个仿真的CPU，被监控的程序被这个仿真CPU解释执行，从而有机会在所有的内存读写指令发生的时候，检测地址的合法性和读操作的合法性。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u014652595/article/details/23660347" >https://blog.csdn.net/u014652595/article/details/23660347<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
</blockquote>
<h2 id="7-什么是动态内存分配请举例"><a class="markdownIt-Anchor" href="#7-什么是动态内存分配请举例"></a> 7、什么是动态内存分配？请举例</h2>
<h2 id="8-如何构造一个类-使得只能在堆上或只能在栈上分配内存"><a class="markdownIt-Anchor" href="#8-如何构造一个类-使得只能在堆上或只能在栈上分配内存"></a> 8、如何构造一个类、使得只能在堆上或只能在栈上分配内存？</h2>
<h2 id="9-请解释指针在内存中的表现形式"><a class="markdownIt-Anchor" href="#9-请解释指针在内存中的表现形式"></a> 9、请解释指针在内存中的表现形式</h2>
<h1 id="c基础"><a class="markdownIt-Anchor" href="#c基础"></a> C++基础</h1>
<h2 id="1-c和c有什么区别"><a class="markdownIt-Anchor" href="#1-c和c有什么区别"></a> 1、C和C++有什么区别</h2>
<p>C是面向过程的语言</p>
<p>C++是面向对象的语言</p>
<p>C++支持继承和多态、泛型编程，函数重载，具有更强大的抽象和灵活构建能力</p>
<p>C不支持上述功能</p>
<p>C<ins>是在C语言基础上发展而来的，因此C</ins>完全兼容C语言，可以将C语言代码直接编译为C<ins>代码。这意味着C</ins>可以使用C语言的库和函数，使得既有的C语言代码可以无缝地与C++代码进行交互。</p>
<p>C语言更加接近底层硬件和相关内存操控，具有高效性和可移植性。</p>
<h2 id="2-c语言的结构体和c的有什么区别"><a class="markdownIt-Anchor" href="#2-c语言的结构体和c的有什么区别"></a> 2、C语言的结构体和C++的有什么区别</h2>
<p>1.C语言中的结构体不能为空，否则会报错</p>
<p>C语言中的结构体只涉及到数据结构，而不涉及到算法，也就是说在C中数据结构和算法是分离的。换句话说就是C语言中的结构体只能定义成员变量，但是不能定义成员函数。</p>
<p>2.在C++中既可以定义成员变量又可以定义成员函数，默认为public</p>
<p>虽然C语言的结构体中不能定义成员函数，但是却可以定义函数指针，不过函数指针本质上不是函数而是指针，所以总的来说C语言中的结构体只是一个复杂数据类型 ，只能定义成员变量，不能定义成员函数，不能用于面向对象编程。</p>
<p>在 C 中，必须显式使用 struct 关键字来声明结构。 在 c + + 中，不需要在 struct 定义类型后使用关键字。</p>
<h2 id="3-c语言的关键字static和c的关键字static有什么区别"><a class="markdownIt-Anchor" href="#3-c语言的关键字static和c的关键字static有什么区别"></a> 3、C语言的关键字static和C++的关键字static有什么区别？</h2>
<blockquote>
<p>C语言中起到两个作用</p>
<p>1.修饰变量；</p>
<p>2.修饰函数；</p>
<p>1.1 修饰全局变量：让全局变量只能在本文件中被直接访问，不能直接的跨文件访问</p>
<p>1.2 修饰局部变量：让局部变量超出了作用域之后还不会被销毁</p>
<p>2.1 修饰函数：修饰函数，不能直接的跨文件访问</p>
<hr />
<p>C++</p>
<p>1.修饰变量</p>
<p>2.修饰函数</p>
<p>3.修饰类中成员变量</p>
<p>4.修饰类中成员函数</p>
<p>3.1 static成员变量只能类内声明，类外初始化</p>
<p>3.2 static成员函数只能使用static修饰的变量</p>
<p>3.3static 对于同一个类只有一份</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/m0_46606290/article/details/119939553" >https://blog.csdn.net/m0_46606290/article/details/119939553<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="4-c-和-java有什么核心区别"><a class="markdownIt-Anchor" href="#4-c-和-java有什么核心区别"></a> 4、C++ 和 Java有什么核心区别？</h2>
<p>C++是一门编译语言，代码经过编译器编译后成为机器码后被执行</p>
<p>java是一种解释型语言，需要jvm来一面解释一面执行</p>
<hr />
<p>重载</p>
<hr />
<p>多重继承</p>
<hr />
<p>C++指针允许直接在内存空间中进行值管理</p>
<h2 id="5-c中a和a有什么区别"><a class="markdownIt-Anchor" href="#5-c中a和a有什么区别"></a> 5、C++中，a和&amp;a有什么区别</h2>
<p>变量</p>
<p>对变量取地址</p>
<p>对于数组对象的理解</p>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240627013802742.png"  alt="image-20240627013802742" ></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1387793" >https://cloud.tencent.com/developer/article/1387793<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="6-c中stactic关键字有什么用"><a class="markdownIt-Anchor" href="#6-c中stactic关键字有什么用"></a> 6、C++中stactic关键字有什么用</h2>
<p><strong>1、全局静态变量</strong></p>
<p>在全局变量加上关键字static，全局变量就定义成一个全局静态变量，存放于静态存储区，在整个程序运行期间一直存在；未经初始化的全局静态变量会被自动初始化为0；全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。</p>
<p><strong>2、局部静态变量</strong></p>
<p>在局部变量之前加上关键字static，局部变量就成为一个局部静态变量，局部静态变量只初始化一次。作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变。</p>
<p><strong>3、静态函数</strong></p>
<p>在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；</p>
<p>注意：不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰。</p>
<p><strong>4、类的静态数据成员</strong></p>
<p>在类中，静态数据成员可以实现多个对象之间的额数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态数据成员是类的所有对象中共享的成员，而不是某个对象的成员。对于多个对象来说，静态数据成员只存储一处，供所有对象共用。</p>
<p><strong>5、类的静态成员函数</strong></p>
<p>静态成员函数和静态数据成员一样，它们都属于类的静态成员，他们都不是对象成员。因此对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中的非静态成员，可以引用类中的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。从中可看出，调用静态成员函数使用如下格式：&lt;类名&gt;::&lt;静态成员函数名&gt;（&lt;参数表&gt;）</p>
<h2 id="7-c中define和const有什么区别"><a class="markdownIt-Anchor" href="#7-c中define和const有什么区别"></a> 7、C++中，#define和const有什么区别？</h2>
<p>define 只是直接展开，没有类型检查</p>
<p>const 有类型，会在编译时期进行类型检查</p>
<h2 id="8-静态链接与动态链接有什么区别"><a class="markdownIt-Anchor" href="#8-静态链接与动态链接有什么区别"></a> 8、静态链接与动态链接有什么区别</h2>
<p>静态库会在**<mark>链接阶段</mark>将静态库中的代码复制到可执行文件中**，当程序在执行的时候，在可执行文件中本身就有了静态库的代码，可以直接调用。</p>
<p>静态链接将所有程序以及相关的库都打包到可执行文件中</p>
<p>动态链接只是将程序</p>
<p>动态库则不会将代码打包到可执行文件中，<strong>而是打包动态库的名称等信息</strong>，在可执行程序运行的时候，需要去找到动态库的文件，然后把动态库加载到内存中才可以使用动态库中的代码。</p>
<p>所需要的函数名和库名打包到可执行文件中，到了程序执行的时候，才会将这些信息传递给操作系统，操作系统再将需要的库文件加载到内存中</p>
<p>静态库被打包到可执行程序中，生成的可执行文件较大，但是程序加载运行速度会比较快，发布程序时，也无需提供静态库，移植比较方便。但是当多个程序链接同一个静态库时，生成的每一个可执行文件中，都会含有这个静态库，相当于在内存中同时运行着两个相同的静态库，比较浪费系统资源。另外，当静态库的内容发生更新时，依赖该静态库的程序也需要重新进行链接，导致程序的更新升级会比较麻烦。</p>
<p>动态库可以实现<mark>进程间资源共享</mark>，比如可执行程序A在<mark>运行时</mark>用到了某个动态库，那么系统会将该动态库的代码<mark>动态加载到内存</mark>中，此时若正在运行的程序B也需要用到该动态库中的代码，则不需要再次加载该动态库，而是可以与程序A共享。此外，当动态库的内容更新时，只需重新编译生成新的动态库即可，而不需要对依赖该动态库的程序重新进行编译链接。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/551170508180516864" >https://www.nowcoder.com/discuss/551170508180516864<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51819222/article/details/129348478" >https://blog.csdn.net/m0_51819222/article/details/129348478<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/551170508180516864" >https://www.nowcoder.com/discuss/551170508180516864<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="9-变量的声明和定义有什么区别"><a class="markdownIt-Anchor" href="#9-变量的声明和定义有什么区别"></a> 9、变量的声明和定义有什么区别</h2>
<p>变量的声明不分配地址</p>
<p>变量的定义为变量分配地址和存储空间</p>
<h2 id="10-typedef-和define-有什么区别呢"><a class="markdownIt-Anchor" href="#10-typedef-和define-有什么区别呢"></a> 10、typedef 和define 有什么区别呢？</h2>
<p>typedef 别名，编译过程的一部分，类型检查，作用域限定。</p>
<p>define 常量，宏，预编译，不进行类型检查。</p>
<p>原文链接：<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36585538/article/details/115696235" >https://blog.csdn.net/qq_36585538/article/details/115696235<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="11-final和override-关键字"><a class="markdownIt-Anchor" href="#11-final和override-关键字"></a> 11、final和override 关键字</h2>
<p>final 类 不能被继承</p>
<p>final 虚函数 不能被重写</p>
<p>override 重写基类中的虚函数（编译器会进行检查）</p>
<h2 id="12-宏定义和函数有什么区别"><a class="markdownIt-Anchor" href="#12-宏定义和函数有什么区别"></a> 12、宏定义和函数有什么区别</h2>
<p>宏定义 预处理阶段 文本替换 不做检查</p>
<p>函数 编译阶段 有编译器做检查</p>
<h2 id="13-sizeof-和strlen-的区别"><a class="markdownIt-Anchor" href="#13-sizeof-和strlen-的区别"></a> 13、sizeof 和strlen 的区别</h2>
<p>sizeof是C++中的一个运算符，用于获取特定类型或对象在内存中所占的字节大小。<strong>其值在编译时就已经确定，并且与运行时无关。</strong></p>
<p>strlen是一个函数，用于计算字符串的长度，即返回字符串中字符的个数，**不包括字符串末尾的空字符’\0’。**它是从代表该字符串的第一个地址开始遍历，直到遇到结束符NULL。</p>
<h2 id="14-简述strcpy-sprintf-与memcpy-的区别"><a class="markdownIt-Anchor" href="#14-简述strcpy-sprintf-与memcpy-的区别"></a> 14、简述strcpy、sprintf 与memcpy 的区别</h2>
<p>strcpy  字符串 另一个复制块 <mark>含有’\0’结束符</mark>的源字符串复制到目标地址空间。</p>
<p>sprintf ``主要用于生成格式化字符串，其返回值是格式化后的字符串长度（不包括末尾的空字符）。如果发生错误，它可能会返回一个负数。</p>
<p>memcpy <code>memcpy</code>则是根据第三个参数来决定复制的字节数，从而控制复制的长度。它逐个字节地从源地址复制到目标地址，直到达到指定的字节数。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/eason22/article/details/137157714" >https://blog.csdn.net/eason22/article/details/137157714<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="15-结构体可以直接赋值吗"><a class="markdownIt-Anchor" href="#15-结构体可以直接赋值吗"></a> 15、结构体可以直接赋值吗</h2>
<p>不可以</p>
<p>可以通过自定义构造函数 拷贝构造函数 赋值构造函数</p>
<h2 id="16-volatile的作用"><a class="markdownIt-Anchor" href="#16-volatile的作用"></a> 16、volatile的作用</h2>
<p>int volatile vInt;</p>
<p>当要求使用 volatile 声明的变量的值的时候，</p>
<p>系统总是重新从它所在的内存读取数据</p>
<h2 id="21-一个指针占用多少字节"><a class="markdownIt-Anchor" href="#21-一个指针占用多少字节"></a> 21、一个指针占用多少字节</h2>
<p>一个指针在32位的计算机上，占4个字节</p>
<p>一个指针在64位的计算机上，占8个字节</p>
<blockquote>
<p>总结</p>
<p>一个指针占多少字节与计算机系统本身是多少位（32、64位）系统有关</p>
<hr />
<p>在32位系统中，</p>
<p><strong>地址总线宽度为32位，所以可以寻址的最大内存空间是4GB（2的32次方），</strong></p>
<p><strong>因此一个指针（即一个地址）需要4字节（32位）的空间来存储。</strong></p>
<p><strong>类似地，在64位系统中，地址总线宽度为64位，所以一个指针需要8字节的空间来存储。</strong></p>
</blockquote>
<blockquote>
<p>多少位的计算机实际上说的是地址总线的宽度</p>
<p>地址是门牌号</p>
<p>里面存的东西是数据，是一个类似于真实的人的人</p>
<p>计算机能够处理的最小单元是 字节Byte 而不是 位bit</p>
<hr />
<p>指针存储的是地址</p>
<p>地址是内存单元的编号</p>
<p>所以，一个指针占几个字节，等于是一个地址的内存单元编号有多长</p>
<hr />
<p>我们都知道，在计算机中，CPU不能直接与硬盘进行数据交换，CPU只能直接跟内存进行数据交换。</p>
<p>而CPU是通过<strong>地址总线、数据总线、控制总线</strong>三条线与内存进行数据传输与操作。</p>
<p>问：假如，我们想通过CPU在内存中读取一个数字3，那么是怎样一个操作呢？</p>
<p>首先，CPU通过地址总线，在内存中找到数字3的地址；</p>
<p>然后，通过控制总线知道该操作是读还是写；</p>
<p>最后，通过数据总线，把数字3传输到CPU中。</p>
<blockquote>
<p>地址总线的宽度决定了CPU的寻址能力，或者说寻址的最大内存容量；</p>
<p>控制总线决定了CPU对其他控件的控制能力以及控制方式。</p>
<p>数据总线的宽度决定了CPU单次数据传输的传送量，</p>
<p>也就是数据传输速度，或者说一次可以处理的数据的宽度；</p>
</blockquote>
<p>我们平时所说的计算机是16位、32位、64位，</p>
<p>指的是计算机CPU中通用寄存器一次性处理、传输、暂时存储的信息的最大长度，</p>
<p>或者说是CPU的数据总线宽度。即CPU在单位时间内(同一时间)能一次处理的二进制数的位数。</p>
<p>即电脑是多少位的，与数据总线有关</p>
<p>地址总线</p>
<p>指针的本质是一个整数，它存储的是内存地址。</p>
<p>通过指针能找到或访问到内存中所有的地方</p>
<p>某计算机的地址总线是32位，那么其一次可以处理的信息是32条，每一条地址总线有0或1两种可能，那么32根地址总线一共有232种可能，也就是其描述的地址空间为0x0000 0000 ~ 232-1。</p>
<p>我们一般需要32个0或1的组合就可以找到内存中所有的地址，而32个0或1的组合，就是32个位，也就是4个字节的大小，因此，我们只需要4个字节就可以找到所有的数据。<br />
所以，在32位的计算机中，指针占4个字节。<br />
同理，在64位的计算机中，指针占8个字节。</p>
<pre><code>这就是上面所说的：地址总线的宽度决定了CPU的寻址能力
</code></pre>
<hr />
<p>同时也可以看出，由于地址总线为32，那么每次寻址的空间为</p>
<p>0000 0000 0000 0000 0000 0000 0000 0000 ~ 232-1，那么CPU的最大内存为</p>
<p>2^32 = 2^22K = 2^12M = 2^2G = 4G</p>
<p>而单位是内存最小操作单位Byte，因此，加上单位Byte后：</p>
<p>2^32Byte = 2^22KB = 2^12MB = 2^2GB = 4GB</p>
<p>也就是，32位的电脑，CPU的最大内存为4GB</p>
<pre><code>此处单位加的是Byte，而不是bit，有兴趣的小伙伴可以查一下为什么
</code></pre>
<p>而64位，最大内存是264Byte = 232 * 232Byte = 232 * 4GB 约等于 17179869184GB。</p>
<pre><code>这就是上面所说的：地址总线的宽度决定了CPU寻址的最大内存容量
</code></pre>
<p><strong>即：在32位系统中，</strong></p>
<p><strong>地址总线宽度为32位，所以可以寻址的最大内存空间是4GB（2的32次方），因此一个指针（即一个地址）需要4字节（32位）的空间来存储。类似地，在64位系统中，地址总线宽度为64位，所以一个指针需要8字节的空间来存储。</strong></p>
<p>常见硬件架构下数据总线和地址总线宽度的示例：</p>
<table>
<thead>
<tr>
<th>CPU架构</th>
<th>数据总线宽度</th>
<th>地址总线宽度</th>
<th>最大内存寻址</th>
<th>指针大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>8位</td>
<td>8位</td>
<td>16位</td>
<td>64KB</td>
<td>1字节</td>
</tr>
<tr>
<td>16位</td>
<td>16位</td>
<td>20位</td>
<td>1MB</td>
<td>2字节</td>
</tr>
<tr>
<td>32位</td>
<td><strong>32位</strong></td>
<td><strong>32 位</strong></td>
<td>4 GB</td>
<td>4字节</td>
</tr>
<tr>
<td>64位</td>
<td><strong>64位</strong></td>
<td><strong>64位</strong></td>
<td>16 EB</td>
<td>8字节</td>
</tr>
</tbody>
</table>
<hr />
<p>1位=1bit/比特，表示一个二进制0或1（比特币）</p>
<p>1字节(Byte) = 8位/bit/比特（字节跳动）</p>
<p>数据存储是以“字节”（Byte）为单位，数据传输大多是以“位”（bit，又名“比特”）为单位</p>
<p>每8个位（bit，简写为b）组成一个字节（Byte，简写为B），是最小一级的信息单位。</p>
<p>1个英文字母（不分大小写）占一个字节Byte的空间</p>
<p>计算机能够处理的最小单元是 字节Byte 而不是 位bit</p>
<p>位bit，是由软件通过位运算符操作的</p>
</blockquote>
<blockquote>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_44369667/article/details/129776458" >https://blog.csdn.net/qq_44369667/article/details/129776458<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000037537285#:~:text=%E6%97%A2%E7%84%B61%E4%B8%AA%E5%AD%97%E8%8A%82%E6%98%AF8,%E8%AE%BF%E9%97%AE%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8D%95%E4%BD%8D%E3%80%82" >https://segmentfault.com/a/1190000037537285#:~:text=既然1个字节是8,访问的最小单位。<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/IOSSHAN/article/details/88944637" >https://blog.csdn.net/IOSSHAN/article/details/88944637<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="28-句柄和指针的区别和联系是什么"><a class="markdownIt-Anchor" href="#28-句柄和指针的区别和联系是什么"></a> 28、句柄和指针的区别和联系是什么</h2>
<p>联系: 都是用来控制与管理资源的，指针直接操作内存，句柄则通过操作系统或者库函数进行资源管理</p>
<p>区别：指针式直接指向具体的内存地址，句柄则是间接引用资源，程序不能通过句柄直接访问资源的内存地址来访问和管理相关内存，而是通过操作系统提供的API或者库函数来操作资源</p>
<h1 id="c面向对象"><a class="markdownIt-Anchor" href="#c面向对象"></a> C++面向对象</h1>
<h2 id="1-什么是类"><a class="markdownIt-Anchor" href="#1-什么是类"></a> 1、什么是类</h2>
<blockquote>
<p>原文</p>
<p>原文链接：<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/h8062651/article/details/136262716" >https://blog.csdn.net/h8062651/article/details/136262716<i class="fas fa-external-link-alt"></i></a></p>
<p>是面向对象程序设计的基本构成单位，它是一种自定义的数据类型，用于封装数据以及操作这些数据的方法。类是创建对象的模板，它定义了对象的属性和行为。对象是根据类创建的实例。</p>
<p>类具有以下基本特性：</p>
<p>封装：封装是将数据（也称为属性或成员变量）和操作这些数据的方法（也称为成员函数或方法）结合在一起的过程。这样，数据就被隐藏或封装在类内部，只能通过类提供的方法进行访问和修改。这有助于保护数据免受外部代码的非法访问和修改，同时也提高了代码的可维护性和可重用性。</p>
<p>继承：继承是从已有的类（称为父类或基类）创建新类（称为子类或派生类）的过程。子类继承了父类的所有属性和方法，同时还可以定义自己的新属性和方法。这样，可以重用已有的代码，提高代码的可重用性和可扩展性。</p>
<p>多态：多态是指允许一个接口（或函数名）有多种实现方式。在 C++ 中，多态通常通过虚函数（virtual functions）实现。子类可以重写父类的虚函数，从而实现多态。这样，在运行时可以根据对象的实际类型调用相应的函数，提高了代码的灵活性和可扩展性。</p>
<p>抽象：抽象是一种隐藏具体实现细节的机制，只展示必要的信息给用户。在 C++ 中，可以通过抽象类（含有至少一个纯虚函数的类）来实现抽象。抽象类不能被实例化，只能被其他类继承。这样，可以定义一种通用的接口或行为，让子类去实现具体的细节。</p>
<p>总的来说，C++ 中的类是一种强大的工具，它使得代码更加模块化、可重用、可维护和可扩展。通过封装、继承、多态和抽象等特性，类可以更好地模拟现实世界中的事物和行为，从而实现更加复杂和灵活的程序设计。</p>
</blockquote>
<blockquote>
<p>总结</p>
<p>自定义的<strong>数据类型</strong></p>
<p>面向<strong>对象</strong>程序设计的<strong>基本单位</strong></p>
<p>能够实现数据和操作封装、继承、多态、抽象等多种特性</p>
<p>封装（保护、可维护、可重用）</p>
<p>继承（重用、可维护、可重用）</p>
<p>多态（多态、灵活、可拓展性）</p>
<p>抽象（对用户：隐藏具体实现细节；对子类：定义一种通用的接口或行为，让子类去实现具体的细节）</p>
</blockquote>
<h2 id="2-面向对象程序设计思想是什么"><a class="markdownIt-Anchor" href="#2-面向对象程序设计思想是什么"></a> 2、面向对象程序设计思想是什么</h2>
<blockquote>
<p>封装（将数据和操作数据的方法捆绑，并对外隐藏，内部实现，提高可复用性，可维护性）</p>
<p>继承（重用、可维护、可重用）</p>
<p>多态（父类接口，子类实现，多态、灵活、可拓展性）</p>
<p>抽象 （提取共性、细节隐藏、保留必要接口）</p>
</blockquote>
<h2 id="25-rtti是什么其原理是什么"><a class="markdownIt-Anchor" href="#25-rtti是什么其原理是什么"></a> 25、RTTI是什么？其原理是什么？</h2>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/RioTian/p/17746167.html" >https://www.cnblogs.com/RioTian/p/17746167.html<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>总结</p>
<p>run time type identification</p>
<p>运行时类型识别</p>
<p>运行的时候检查所指实际类型</p>
<p>有虚函数的时候，基类指针可以指向任何派生对象</p>
<p>类型的确定是要在运行的时候进行类型识别</p>
<blockquote>
<p>原理</p>
<p>1.dynamic_cast操作符，<strong>将基类类型的指针或引用安全地转换为派生类型的指针或引用。</strong></p>
<blockquote>
<p>当我们进行dynamic_cast时，编译器会帮我们进行语法检查。</p>
<p>如果指针的静态类型和目标类型相同，那么就什么事情都不做；</p>
<p>否则，首先对指针进行调整，使得它指向vftable，并将其和调整之后的指针、调整的偏移量、静态类型以及目标类型传递给内部函数。其中最后一个参数指明转换的是指针还是引用。</p>
</blockquote>
<p>2.<code>typeid</code> 运算符用于获取对象的类型信息，它返回一个 <code>std::type_info</code> 对象。</p>
<blockquote>
<p><strong>编译时信息</strong>：</p>
<ul>
<li>当编译器遇到<code>typeid</code>操作符时，它会检查操作数的类型。</li>
<li>对于静态类型（如基类指针或引用），编译器生成适当的代码来获取类型信息。</li>
</ul>
<p><strong>运行时信息</strong>（RTTI）：</p>
<ul>
<li>如果操作数是多态类型（即包含虚函数的类类型），编译器会在对象中存储运行时类型信息。通常，这些信息存储在对象的虚表（vtable）中。</li>
<li>在程序运行时，<code>typeid</code>操作符会利用这些信息来确定对象的动态类型。</li>
</ul>
</blockquote>
<hr />
<p><code>typeid</code>操作符返回一个<code>const std::type_info&amp;</code>，它是一个标准库中的类，包含了类型信息。</p>
<p><code>std::type_info</code>类通常包含以下成员函数：</p>
<ul>
<li><code>name()</code>：返回一个C风格字符串，表示类型的名称。</li>
<li><code>before(const type_info&amp; rhs) const</code>：提供类型的顺序比较。</li>
<li><code>operator==</code>和<code>operator!=</code>：用于比较类型信息。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="29-为什么析构函数一般写成虚函数"><a class="markdownIt-Anchor" href="#29-为什么析构函数一般写成虚函数"></a> 29、为什么析构函数一般写成虚函数</h2>
<ul>
<li>虚函数的特点</li>
</ul>
<blockquote>
<p>定义一个函数为虚函数，不代表函数为不被实现的函数。</p>
<p>定义他为虚函数是为了<strong>允许基类调用子类</strong>。</p>
<p>定义一个函数为纯虚函数，才代表函数没有被实现。</p>
<p>定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。</p>
</blockquote>
<ul>
<li>原因</li>
</ul>
<blockquote>
<p>基类指针指向派生类的时候</p>
<p>若基类析构函数不声明为虚函数</p>
<p>在析构时，只会调用基类而不会调用派生类的析构函数，从而导致相关资源可能释放管理不完全，导致内存泄漏</p>
</blockquote>
<blockquote>
<p><strong>实际上，派生类的析构函数会自动调用基类的析构函数。 只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual关键字声明，都自动成为虚析构函数</strong></p>
</blockquote>
<h1 id="c-语言面试题"><a class="markdownIt-Anchor" href="#c-语言面试题"></a> C 语言面试题</h1>
<h2 id="请解释c语言中的extern关键字并描述其在多文件编程中的应用"><a class="markdownIt-Anchor" href="#请解释c语言中的extern关键字并描述其在多文件编程中的应用"></a> 请解释C语言中的extern关键字，并描述其在多文件编程中的应用</h2>

                </div>
                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/06/23/20240623-%E6%85%A7%E6%95%8F%E7%9A%84%E8%AF%9D/"
                                   title="20240623 今日的头脑风暴"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">20240623 今日的头脑风暴</span>
                                        <span class="post-nav-item">Prev posts</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/06/21/20240621-%E9%80%92%E5%BD%92%E5%9B%9E%E6%BA%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BE%93%E5%87%BA/"
                                   title="20240621 算法：递归回溯字符串输出"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">20240621 算法：递归回溯字符串输出</span>
                                        <span class="post-nav-item">Next posts</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;Comments
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">Comment plugin failed to load</span>
    <button class="reload keep-button">Click to reload</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">Loading comment plugin</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="valine-container">
        <div id="vcomments"></div>
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        ></script>
        <script 
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        >
          window.KeepCommentPlugin.initValine = () => {
            const config = {
              el: '#vcomments',
              appId: 'DYpeXIX0A58ayXv2jFns418I-gzGzoHsz',
              appKey: 'aVeRlE1OlBTUKleFs6ZKOrga',
              meta: ['nick', 'mail', 'link'],
              avatar: 'wavatar',
              enableQQ: true,
              placeholder: '请在此输入您的留言',
              lang: 'zh-Hans'.toLowerCase()
            }

            if ('') {
              config.serverURLs = ''
            }

            if (window?.Valine) {
              new Valine(config)
              window.KeepCommentPlugin.hideLoading()
            } else {
              setTimeout(() => {
                window.KeepCommentPlugin.initValine()
              }, 1000)
            }
          }

          if ('false' === 'true') {
            setTimeout(() => {
              window.KeepCommentPlugin.initValine()
            }, 1200)
          } else {
            window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initValine)
          }
        </script>
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text"> 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text"> C++11新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#30-unique_ptr%E5%92%8Cshared_ptr%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.</span> <span class="nav-text"> 30、unique_ptr和shared_ptr的区别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shared_ptr%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">2.2.</span> <span class="nav-text"> shared_ptr是线程安全的吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-c11%E5%BC%95%E5%85%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%9A%84%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text"> 1、C++11引入了哪些新的指针类型？简单描述一下它们的作用*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c11%E4%B8%AD%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E6%98%AF%E6%80%8E%E6%A0%B7%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84"><span class="nav-number">2.4.</span> <span class="nav-text"> C++11中的右值引用与移动语义是怎样提高性能的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c11%E4%B8%AD%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.</span> <span class="nav-text"> C11中右值左值相互转换的问题*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-c%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88%E5%AF%B9auto%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3%E5%B9%B6%E4%B8%94%E8%B0%88%E8%B0%88%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.6.</span> <span class="nav-text"> 3、C++请你谈谈对auto关键字的理解,并且谈谈在实际应用中它的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-c11%E4%B8%ADlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83%E4%BB%AC"><span class="nav-number">2.7.</span> <span class="nav-text"> 4 、C++11中lambda表达式是什么，如何使用它们</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E5%86%85%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text"> C++内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text"> 全局变量和静态变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.2.</span> <span class="nav-text"> 栈和堆的区别是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%8C%BAstack"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 栈区（stack）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%8C%BAheap"><span class="nav-number">3.2.2.</span> <span class="nav-text"> 堆区（heap）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.3.</span> <span class="nav-text"> 3、内存泄漏的场景有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D"><span class="nav-number">3.4.</span> <span class="nav-text"> 4、内存分配的方式有多少种</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">3.4.1.</span> <span class="nav-text"> 从静态存储区分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">3.4.2.</span> <span class="nav-text"> 从栈上分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">3.4.3.</span> <span class="nav-text"> 从堆上分配内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.5.</span> <span class="nav-text"> 5、静态内存分配和动态内存分配的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AE%83"><span class="nav-number">3.6.</span> <span class="nav-text"> 6、什么是内存泄漏？如何避免它？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7valgrind"><span class="nav-number">3.7.</span> <span class="nav-text"> 内存泄露检测工具valgrind</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%AF%B7%E4%B8%BE%E4%BE%8B"><span class="nav-number">3.8.</span> <span class="nav-text"> 7、什么是动态内存分配？请举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E7%B1%BB-%E4%BD%BF%E5%BE%97%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%88%96%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">3.9.</span> <span class="nav-text"> 8、如何构造一个类、使得只能在堆上或只能在栈上分配内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E8%AF%B7%E8%A7%A3%E9%87%8A%E6%8C%87%E9%92%88%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.10.</span> <span class="nav-text"> 9、请解释指针在内存中的表现形式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E5%9F%BA%E7%A1%80"><span class="nav-number">4.</span> <span class="nav-text"> C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-c%E5%92%8Cc%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text"> 1、C和C++有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-c%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8Cc%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.</span> <span class="nav-text"> 2、C语言的结构体和C++的有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97static%E5%92%8Cc%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97static%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text"> 3、C语言的关键字static和C++的关键字static有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-c-%E5%92%8C-java%E6%9C%89%E4%BB%80%E4%B9%88%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="nav-number">4.4.</span> <span class="nav-text"> 4、C++ 和 Java有什么核心区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-c%E4%B8%ADa%E5%92%8Ca%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.5.</span> <span class="nav-text"> 5、C++中，a和&amp;a有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-c%E4%B8%ADstactic%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">4.6.</span> <span class="nav-text"> 6、C++中stactic关键字有什么用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-c%E4%B8%ADdefine%E5%92%8Cconst%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.7.</span> <span class="nav-text"> 7、C++中，#define和const有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.8.</span> <span class="nav-text"> 8、静态链接与动态链接有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.9.</span> <span class="nav-text"> 9、变量的声明和定义有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-typedef-%E5%92%8Cdefine-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2"><span class="nav-number">4.10.</span> <span class="nav-text"> 10、typedef 和define 有什么区别呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-final%E5%92%8Coverride-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.11.</span> <span class="nav-text"> 11、final和override 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.12.</span> <span class="nav-text"> 12、宏定义和函数有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-sizeof-%E5%92%8Cstrlen-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.13.</span> <span class="nav-text"> 13、sizeof 和strlen 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E7%AE%80%E8%BF%B0strcpy-sprintf-%E4%B8%8Ememcpy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.14.</span> <span class="nav-text"> 14、简述strcpy、sprintf 与memcpy 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E5%90%97"><span class="nav-number">4.15.</span> <span class="nav-text"> 15、结构体可以直接赋值吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-volatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.16.</span> <span class="nav-text"> 16、volatile的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82"><span class="nav-number">4.17.</span> <span class="nav-text"> 21、一个指针占用多少字节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E5%8F%A5%E6%9F%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.18.</span> <span class="nav-text"> 28、句柄和指针的区别和联系是什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text"> C++面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB"><span class="nav-number">5.1.</span> <span class="nav-text"> 1、什么是类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.2.</span> <span class="nav-text"> 2、面向对象程序设计思想是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-rtti%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B6%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.3.</span> <span class="nav-text"> 25、RTTI是什么？其原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.</span> <span class="nav-text"> 29、为什么析构函数一般写成虚函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text"> C 语言面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8Ac%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97%E5%B9%B6%E6%8F%8F%E8%BF%B0%E5%85%B6%E5%9C%A8%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">6.1.</span> <span class="nav-text"> 请解释C语言中的extern关键字，并描述其在多文件编程中的应用</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">明昧</a>
                
            </div>

            <div class="theme-info info-item default">
                Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">Unique Visitor</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">Page View</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text"> 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text"> C++11新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#30-unique_ptr%E5%92%8Cshared_ptr%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.1.</span> <span class="nav-text"> 30、unique_ptr和shared_ptr的区别是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shared_ptr%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">2.2.</span> <span class="nav-text"> shared_ptr是线程安全的吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-c11%E5%BC%95%E5%85%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E6%96%B0%E7%9A%84%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AE%83%E4%BB%AC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.3.</span> <span class="nav-text"> 1、C++11引入了哪些新的指针类型？简单描述一下它们的作用*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c11%E4%B8%AD%E7%9A%84%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E6%98%AF%E6%80%8E%E6%A0%B7%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84"><span class="nav-number">2.4.</span> <span class="nav-text"> C++11中的右值引用与移动语义是怎样提高性能的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c11%E4%B8%AD%E5%8F%B3%E5%80%BC%E5%B7%A6%E5%80%BC%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.</span> <span class="nav-text"> C11中右值左值相互转换的问题*</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-c%E8%AF%B7%E4%BD%A0%E8%B0%88%E8%B0%88%E5%AF%B9auto%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3%E5%B9%B6%E4%B8%94%E8%B0%88%E8%B0%88%E5%9C%A8%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E4%B8%AD%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.6.</span> <span class="nav-text"> 3、C++请你谈谈对auto关键字的理解,并且谈谈在实际应用中它的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-c11%E4%B8%ADlambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%AE%83%E4%BB%AC"><span class="nav-number">2.7.</span> <span class="nav-text"> 4 、C++11中lambda表达式是什么，如何使用它们</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E5%86%85%E5%AD%98"><span class="nav-number">3.</span> <span class="nav-text"> C++内存</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.1.</span> <span class="nav-text"> 全局变量和静态变量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">3.2.</span> <span class="nav-text"> 栈和堆的区别是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%8C%BAstack"><span class="nav-number">3.2.1.</span> <span class="nav-text"> 栈区（stack）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%8C%BAheap"><span class="nav-number">3.2.2.</span> <span class="nav-text"> 堆区（heap）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.3.</span> <span class="nav-text"> 3、内存泄漏的场景有哪些</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D"><span class="nav-number">3.4.</span> <span class="nav-text"> 4、内存分配的方式有多少种</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">3.4.1.</span> <span class="nav-text"> 从静态存储区分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">3.4.2.</span> <span class="nav-text"> 从栈上分配内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%A0%86%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">3.4.3.</span> <span class="nav-text"> 从堆上分配内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%9D%99%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.5.</span> <span class="nav-text"> 5、静态内存分配和动态内存分配的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%AE%83"><span class="nav-number">3.6.</span> <span class="nav-text"> 6、什么是内存泄漏？如何避免它？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7valgrind"><span class="nav-number">3.7.</span> <span class="nav-text"> 内存泄露检测工具valgrind</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%AF%B7%E4%B8%BE%E4%BE%8B"><span class="nav-number">3.8.</span> <span class="nav-text"> 7、什么是动态内存分配？请举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%A6%82%E4%BD%95%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E7%B1%BB-%E4%BD%BF%E5%BE%97%E5%8F%AA%E8%83%BD%E5%9C%A8%E5%A0%86%E4%B8%8A%E6%88%96%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="nav-number">3.9.</span> <span class="nav-text"> 8、如何构造一个类、使得只能在堆上或只能在栈上分配内存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E8%AF%B7%E8%A7%A3%E9%87%8A%E6%8C%87%E9%92%88%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.10.</span> <span class="nav-text"> 9、请解释指针在内存中的表现形式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E5%9F%BA%E7%A1%80"><span class="nav-number">4.</span> <span class="nav-text"> C++基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-c%E5%92%8Cc%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.</span> <span class="nav-text"> 1、C和C++有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-c%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8Cc%E7%9A%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.</span> <span class="nav-text"> 2、C语言的结构体和C++的有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97static%E5%92%8Cc%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97static%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.3.</span> <span class="nav-text"> 3、C语言的关键字static和C++的关键字static有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-c-%E5%92%8C-java%E6%9C%89%E4%BB%80%E4%B9%88%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="nav-number">4.4.</span> <span class="nav-text"> 4、C++ 和 Java有什么核心区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-c%E4%B8%ADa%E5%92%8Ca%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.5.</span> <span class="nav-text"> 5、C++中，a和&amp;a有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-c%E4%B8%ADstactic%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">4.6.</span> <span class="nav-text"> 6、C++中stactic关键字有什么用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-c%E4%B8%ADdefine%E5%92%8Cconst%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.7.</span> <span class="nav-text"> 7、C++中，#define和const有什么区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.8.</span> <span class="nav-text"> 8、静态链接与动态链接有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.9.</span> <span class="nav-text"> 9、变量的声明和定义有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-typedef-%E5%92%8Cdefine-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2"><span class="nav-number">4.10.</span> <span class="nav-text"> 10、typedef 和define 有什么区别呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-final%E5%92%8Coverride-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.11.</span> <span class="nav-text"> 11、final和override 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8C%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">4.12.</span> <span class="nav-text"> 12、宏定义和函数有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-sizeof-%E5%92%8Cstrlen-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.13.</span> <span class="nav-text"> 13、sizeof 和strlen 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E7%AE%80%E8%BF%B0strcpy-sprintf-%E4%B8%8Ememcpy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.14.</span> <span class="nav-text"> 14、简述strcpy、sprintf 与memcpy 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E5%90%97"><span class="nav-number">4.15.</span> <span class="nav-text"> 15、结构体可以直接赋值吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-volatile%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.16.</span> <span class="nav-text"> 16、volatile的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82"><span class="nav-number">4.17.</span> <span class="nav-text"> 21、一个指针占用多少字节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E5%8F%A5%E6%9F%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.18.</span> <span class="nav-text"> 28、句柄和指针的区别和联系是什么</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text"> C++面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB"><span class="nav-number">5.1.</span> <span class="nav-text"> 1、什么是类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.2.</span> <span class="nav-text"> 2、面向对象程序设计思想是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-rtti%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B6%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">5.3.</span> <span class="nav-text"> 25、RTTI是什么？其原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.</span> <span class="nav-text"> 29、为什么析构函数一般写成虚函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#c-%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text"> C 语言面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8Ac%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97%E5%B9%B6%E6%8F%8F%E8%BF%B0%E5%85%B6%E5%9C%A8%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">6.1.</span> <span class="nav-text"> 请解释C语言中的extern关键字，并描述其在多文件编程中的应用</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->


<!-- lazyload -->


<div class="">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
