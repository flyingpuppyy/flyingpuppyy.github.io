<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="明昧">
    
    <title>
        
            20220819 lambda |
        
        行者无畏
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"flyingpuppyy.github.io","root":"/","language":"zh-Hans"}
    KEEP.theme_config = {"base_info":{"primary_color":"#FA8072","title":"行者无畏","author":"明昧","avatar":"/images/tou.jpeg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives","categories":"/categories"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"你过于安静勇敢，我忘了你正在承受苦痛","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":false,"preload":false},"comment":{"enable":true,"use":"valine","valine":{"appid":"DYpeXIX0A58ayXv2jFns418I-gzGzoHsz","appkey":"aVeRlE1OlBTUKleFs6ZKOrga","server_urls":null,"placeholder":"请在此输入您的留言"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":false,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"encrypt":{"enable":true},"root":"","source_data":{},"version":"4.1.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               行者无畏
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                首页
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                归档
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                
                                分类
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >首页</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        20220819 lambda
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/tou.jpeg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">明昧</span>
                                
                                    <span class="author-badge">Lv5</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-06-25 22:31:03</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Tue Jun 25 2024 22:36:12 GMT+0800">2024-06-25 22:36:12</span>
            </span>
        

        

        

        
        
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <h1 id="20220819-lambda"><a href="#20220819-lambda" class="headerlink" title="20220819 lambda"></a>20220819 lambda</h1><ul>
<li>理解路线：闭包行为-》三种闭包实现-》函数对象-》lambda</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li><p>lambda的捕捉变量的范围到底是在哪里，全局变量而已？还是局部变量而已？还是某些遵循特定规则的作用域？遇到相同的变量名称lambda怎样进行捕捉？</p>
</li>
<li><p>C++Lambda 作用范围-》在<em>Lambda</em>表达式内可以访问当前<em>作用</em>域的变量,这是<em>Lambda</em>表达式的<strong>闭包(Closure)行为。</strong>-》</p>
</li>
</ul>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><ul>
<li><p><strong>百度定义</strong>：</p>
<p>闭包是指可以包含自由（未绑定到特定对象）变量的代码块；</p>
<p>这些变量不是在这个代码块内或者任何全局上下文中定义的，而是<strong>在定义代码块的环境中定义（局部变量）？？</strong>。</p>
<p>“闭包” 一词来源于以下两者的结合：</p>
<p>要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）</p>
<p>和为自由变量提供绑定的计算环境（作用域）。</p>
<hr>
</li>
<li><p>通俗理解</p>
<p>闭包有很多种定义，</p>
<p>一种说法是，</p>
<p>闭包是带有上下文的函数，</p>
<p>就是有状态的函数，</p>
<p>更直接一些，就是个类。</p>
<p>一个函数, 带上了一个状态, 就变成了闭包了。</p>
</li>
</ul>
<hr>
<ul>
<li>闭包定义：<strong>带上状态的函数</strong></li>
<li>理解:<strong>带上状态</strong></li>
</ul>
<p>什么叫 <strong>“带上状态” <strong>呢? 意思是这个闭包</strong>有属于自己的变量</strong>, 这些个变量的值是创建闭包的时候设置的, 并在调用闭包的时候, 可以访问这些变量.</p>
<ul>
<li><strong>内部包含 static 变量的函数, 不是闭包</strong>, 因为这个 static 变量不能捆绑. 你不能捆绑不同的 static 变量. 这个在编译的时候已经确定了.</li>
</ul>
<ul>
<li><strong>闭包的状态捆绑, 必须发生在运行时</strong>.</li>
</ul>
<hr>
<h1 id="闭包的三种实现"><a href="#闭包的三种实现" class="headerlink" title="闭包的三种实现"></a>闭包的三种实现</h1><p>C++ 里使用闭包有３个办法</p>
<h1 id="重载-operator-函数对象"><a href="#重载-operator-函数对象" class="headerlink" title="重载 operator()&#x2F;函数对象"></a>重载 operator()&#x2F;函数对象</h1><ul>
<li><p>函数对象：</p>
<p><strong>重载操作符（）的类对象。</strong>当用该对象调用此操作符时，其表现形式如同普通函数调用一般，因此取名叫函数对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( <span class="type">int</span> val )</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">0</span> ? val : -val;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为闭包是一个函数+一个状态, 这个状态通过 隐含的 this 指针传入. </p>
<p>所以 闭包必然是一个函数对象.</p>
<p>默认传入的 this 指针提供了访问成员变量的途径.</p>
</blockquote>
</li>
<li><p>事实上, lambda 和 bind 的原理都是这个.</p>
</li>
</ul>
<hr>
<h2 id="用法之直接调用"><a href="#用法之直接调用" class="headerlink" title="用法之直接调用"></a>用法之直接调用</h2><ul>
<li>例子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunctor</span></span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyFunctor</span>(<span class="type">float</span> f) : <span class="built_in">round</span>(f) &#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">float</span> f)</span> </span>&#123; <span class="keyword">return</span> f + round; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> round;</span><br><span class="line">&#125;;</span><br><span class="line">	<span class="type">float</span> round = <span class="number">0.5</span>;</span><br><span class="line">	<span class="function">MyFunctor <span class="title">f</span><span class="params">(round)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当重载（）后，像11行一样传入float数值后，</p>
<p>第一步：MyFunctor 会被传入数据进行初始化</p>
<p>第二步：然后就直接执行重载operator（）里面的内容</p>
<p>完美实现了（函数+状态）的实现</p>
</blockquote>
<ul>
<li>例二</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CAverage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function">    </span>&#123;  <span class="comment">//重载()运算符</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)(a1 + a2 + a3) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CAverage average;  <span class="comment">//能够求三个整数平均数的函数对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">average</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>);  <span class="comment">//等价于 cout &lt;&lt; average.operator(3, 2, 3);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>例三</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyFunctor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MyFunctor</span>(<span class="type">int</span> temp): <span class="built_in">round</span>(temp) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> temp)</span> </span>&#123;<span class="keyword">return</span> temp + round; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> round;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mytest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> round = <span class="number">2</span>;</span><br><span class="line">  <span class="function">MyFunctor <span class="title">f</span><span class="params">(round)</span></span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;result: &quot;</span> &lt;&lt; <span class="built_in">f</span>(<span class="number">1</span>) &lt;&lt; std::endl; <span class="comment">// operator()(int temp)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">mytest</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><h2 id="例子理解"><a href="#例子理解" class="headerlink" title="例子理解"></a>例子理解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abssort</span><span class="params">(<span class="type">float</span>* x, <span class="type">unsigned</span> n)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(x, x + n,</span><br><span class="line">        [](<span class="type">float</span> a, <span class="type">float</span> b) &#123;</span><br><span class="line">            <span class="built_in">return</span> (std::<span class="built_in">abs</span>(a) &lt; std::<span class="built_in">abs</span>(b));</span><br><span class="line">        &#125; </span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的实例中<code>std::sort</code>函数第三个参数应该是传递一个排序规则的函数，但是这个实例中直接将排序函数的实现写在应该传递函数的位置，省去了定义排序函数的过程，对于这种不需要复用，且短小的函数，直接传递函数体可以<strong>增加代码的可读性。</strong></p>
<h3 id="args-使用"><a href="#args-使用" class="headerlink" title="[    ] ( args )使用"></a>[    ] ( args )使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda返回类型相当于使用decltyp根据返回值推断得到；如果lambda不包含返回语句，推断出的返回类型将为void。</span></span><br><span class="line">[](<span class="type">int</span> x) &#123;<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用整个lambda表达式替换函数指针或伪函数构造函数</span></span><br><span class="line">count3 = std::<span class="built_in">count_if</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(),[](<span class="type">int</span> x)&#123;<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的</p>
<p><code>[](int x)&#123;return x % 3 == 0;&#125;</code></p>
<p>就是lambda表达式</p>
</blockquote>
<h3 id="用"><a href="#用" class="headerlink" title="[ ]用"></a>[ ]用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>更简单体现在没有参数传入</p>
<p>这意味着</p>
<p><strong>该lambda表达式创建的时候不需要传入任何的参数</strong></p>
</blockquote>
<h3 id="返回类型可以自动推断？"><a href="#返回类型可以自动推断？" class="headerlink" title="返回类型可以自动推断？"></a>返回类型可以自动推断？</h3><p>总结：</p>
<p>lambda的类型推断</p>
<p>在lambda表达式完全由一条返回语句组成的时候可以实现</p>
<p>哪怕if-else式的返回语句这样搞就不行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="type">double</span> x)-&gt;<span class="type">double</span>&#123;<span class="type">int</span> y = x; <span class="keyword">return</span> x – y;&#125; </span><br><span class="line"><span class="comment">// return type is double</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//仅当lambda表达式完全由一条返回语句组成时，自动类型推断才管用</span></span><br><span class="line"><span class="comment">//否则,需要使用新增的返回类型后置语法</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>另一个例子</p>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223216673.png"  alt="image-20240625223216673"></p>
<blockquote>
<p>上述例子如果改成下面这样就是错误的</p>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223248104.png"  alt="image-20240625223248104"></p>
<p>&#x3D;&#x3D;该例子中，表达式函数体内包含不止一个return语句，所以是错误的&#x3D;&#x3D;</p>
<p><strong>我靠我查资料又看到人家可以编译通过唉！！，lambda的类型推断编译器到底是怎么搞的，靠北</strong></p>
</blockquote>
</blockquote>
<h3 id="auto-lambda-有名-lambda"><a href="#auto-lambda-有名-lambda" class="headerlink" title="auto lambda&#x2F;有名 lambda"></a>auto lambda&#x2F;有名 lambda</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mod3 = [](<span class="type">int</span> x)&#123;<span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;&#125; <span class="comment">// mod3 a name for the lambda</span></span><br><span class="line"><span class="comment">//可以像使用函数一样使用带有名字的lambda函数</span></span><br><span class="line"><span class="type">bool</span> result = <span class="built_in">mod3</span>(z); <span class="comment">// result is true if z % 3 == 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="传参区别"><a href="#传参区别" class="headerlink" title="[ ]传参区别"></a>[ ]传参区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[z]---按值访问变量</span></span><br><span class="line"><span class="comment">//[&amp;count]---按引用访问变量</span></span><br><span class="line"><span class="comment">//[&amp;]---按引用访问所有动态变量</span></span><br><span class="line"><span class="comment">//[=]---按值访问所有动态变量</span></span><br><span class="line"><span class="comment">//[&amp;,ted]---按值访问ted,按引用访问其他动态变量</span></span><br><span class="line"><span class="comment">//其他混合方式也允许</span></span><br><span class="line"><span class="type">int</span> count13 = <span class="number">0</span>;</span><br><span class="line">std::for_each(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(),</span><br><span class="line">[&amp;count13](<span class="type">int</span> x)&#123;count13 += x % <span class="number">13</span> == <span class="number">0</span>;&#125;);<span class="comment">//此时count13就可以记录可以整除13的x的数量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的</p>
<p><code>[&amp;count13](int x)&#123;count13 += x % 13 == 0;&#125;);</code></p>
<p>就是lambda表达式</p>
</blockquote>
<h3 id="lambda修饰符"><a href="#lambda修饰符" class="headerlink" title="lambda修饰符"></a>lambda修饰符</h3><p>这一部分是可以省略的，常见的修饰符有两个，一个是mutable，另一个是exception</p>
<h4 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非mutable</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> test = [x]()&#123; x++; &#125;;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//含mutable</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> test = [x]()<span class="keyword">mutable</span>&#123; x++; &#125;;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分别测试一下</strong></p>
<blockquote>
<p>第一个无法进行编译，因为值传入</p>
<p>第二个可以运行，输出结果是1</p>
<hr>
<p>原因：</p>
<p>从展开结果可以看出，实际上编译器就是把<code>lambda</code>表达式转化成为一个类，<code>lambda</code>表达式捕获的值为该类的数据成员。上例中<code>lambda</code>表达式被转化为类<code>__lambda_8_12</code>，其重载了<code>operator()</code>，由于使用了<code>mutable</code>修饰，解除了<code>operator()</code>的<code>const</code>修饰（默认情况下是<code>const</code>的）。数据成员为捕获到的<code>a</code>，并将其实例化为类对象<code>f</code>，然后调用了两次<code>operator()</code>，因此<code>a</code>值的打印也是累加的，即两次结果分别为<code>1</code>和<code>2</code>。</p>
<p>总 结</p>
<p>lambda<code>表达式实际上就是一个独有的无名非联合非聚合类，其捕获的数据是它的类成员，该类重载了</code>operator()<code>，且默认情况下该成员函数是</code>const<code>，可以使用</code>mutable<code>关键字来去除</code>const</p>
<hr>
<p><a class="link"   target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1762930363843792781&wfr=spider&for=pc" >https://baijiahao.baidu.com/s?id=1762930363843792781&amp;wfr=spider&amp;for=pc<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<p><strong>还可以改为值引用来进行理解</strong></p>
<h4 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h4><p>有待补充</p>
<h3 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h3><ul>
<li>捕捉列表<strong>不允许变量重复传递</strong></li>
<li>总表</li>
</ul>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223305565.png"  alt="image-20240625223305565"></p>
<hr>
<h5 id="1-表示不捕获任何变量"><a href="#1-表示不捕获任何变量" class="headerlink" title="1.[]表示不捕获任何变量"></a>1.<code>[]</code>表示不捕获任何变量</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> function = ([]&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">function</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-var-表示值传递方式捕获变量var"><a href="#2-var-表示值传递方式捕获变量var" class="headerlink" title="2.[var]表示值传递方式捕获变量var"></a>2.<code>[var]</code>表示值传递方式捕获变量<code>var</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> function = ([num]&#123;</span><br><span class="line">		std::cout &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">function</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>创建时拷贝，不是调用时拷贝</strong></p>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223319117.png"  alt="image-20240625223319117"></p>
</blockquote>
<h5 id="3-表示值传递方式捕获所有父作用域的变量（包括this）"><a href="#3-表示值传递方式捕获所有父作用域的变量（包括this）" class="headerlink" title="3.[=]表示值传递方式捕获所有父作用域的变量（包括this）"></a>3.<code>[=]</code>表示值传递方式捕获所有父作用域的变量（包括this）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> function = ([=]&#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="string">&quot;, &quot;</span> </span><br><span class="line">                &lt;&lt; <span class="string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">function</span>();</span><br></pre></td></tr></table></figure>

<h5 id="4-var-表示引用传递捕捉变量var"><a href="#4-var-表示引用传递捕捉变量var" class="headerlink" title="4.    [&amp;var]表示引用传递捕捉变量var"></a>4.<code>    [&amp;var]表示引用传递捕捉变量var</code></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> function = ([&amp;num]&#123;</span><br><span class="line">		num = <span class="number">1000</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">function</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>才有引用的方式捕获变量，<strong>必须保证该变量在lambda调用时仍然存在</strong></p>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223332452.png"  alt="image-20240625223332452"></p>
</blockquote>
<h5 id="5-表示引用传递方式捕捉所有父作用域的变量（包括this）"><a href="#5-表示引用传递方式捕捉所有父作用域的变量（包括this）" class="headerlink" title="5.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）"></a>5.<code>[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）</code></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int index = 1;</span><br><span class="line">int num = 100;</span><br><span class="line">auto function = ([&amp;]&#123;</span><br><span class="line">		num = 1000;</span><br><span class="line">		index = 2;</span><br><span class="line">		std::cout &lt;&lt; &quot;index: &quot;&lt;&lt; index &lt;&lt; &quot;, &quot; </span><br><span class="line">            &lt;&lt; &quot;num: &quot;&lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">function();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="6-this-表示值传递方式捕捉当前的this指针"><a href="#6-this-表示值传递方式捕捉当前的this指针" class="headerlink" title="6.[this]表示值传递方式捕捉当前的this指针"></a>6.<code>[this]</code>表示值传递方式捕捉当前的this指针</h5><p>我感觉这样子就能够实现对类其他内部数据和函数的访问和输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Lambda</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void sayHello() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    void lambda() &#123;</span><br><span class="line">        auto function = [this]&#123; </span><br><span class="line">            this-&gt;sayHello(); </span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    Lambda demo;</span><br><span class="line">    demo.lambda();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="7-拷贝与引用混合"><a href="#7-拷贝与引用混合" class="headerlink" title="7.[&#x3D;, &amp;] 拷贝与引用混合"></a>7.[&#x3D;, &amp;] 拷贝与引用混合</h5><ul>
<li><code>[=, &amp;a, &amp;b]</code>表示以引用传递的方式捕捉变量<code>a</code>和<code>b</code>，以值传递方式捕捉其它所有变量。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span> function = ([=, &amp;index, &amp;num]&#123;</span><br><span class="line">		num = <span class="number">1000</span>;</span><br><span class="line">		index = <span class="number">2</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;index: &quot;</span>&lt;&lt; index &lt;&lt; <span class="string">&quot;, &quot;</span> </span><br><span class="line">            &lt;&lt; <span class="string">&quot;num: &quot;</span>&lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="built_in">function</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出是 2 1000</p>
</blockquote>
<ul>
<li><code>[&amp;, a, this]</code>表示以值传递的方式捕捉变量<code>a</code>和<code>this</code>，引用传递方式捕捉其它所有变量。</li>
</ul>
<p>不过值得注意的是，捕捉列表<strong>不允许变量重复传递</strong>。下面一些例子就是典型的重复，会导致编译时期的错误。例如：</p>
<ul>
<li><code>[=,a]</code>这里已经以值传递方式捕捉了所有变量，但是重复捕捉<code>a</code>了，会报错的；</li>
<li><code>[&amp;,&amp;this]</code>这里<code>&amp;</code>已经以引用传递方式捕捉了所有变量，再捕捉<code>this</code>也是一种重复。</li>
</ul>
<h4 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> function = [] (<span class="type">int</span> first, <span class="type">int</span> second)&#123;</span><br><span class="line">    <span class="keyword">return</span> first + second;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="built_in">function</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223347833.png"  alt="image-20240625223347833"></p>
<ol>
<li>捕获列表。在C++规范中也称为Lambda导入器， 捕获列表总是出现在Lambda函数的开始处。实际上，<code>[]</code>是Lambda引出符。编译器根据该引出符判断接下来的代码是否是Lambda函数，捕获列表能够捕捉上下文中的变量以供Lambda函数使用。</li>
<li>参数列表。与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略。</li>
<li>可变规格。<code>mutable</code>修饰符， 默认情况下Lambda函数总是一个<code>const</code>函数，<code>mutable</code>可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。</li>
<li>异常说明。用于Lamdba表达式内部函数抛出异常。</li>
<li>返回类型。 追踪返回类型形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”-&gt;”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。</li>
<li>lambda函数体。内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。</li>
</ol>
<h2 id="可以访问的变量"><a href="#可以访问的变量" class="headerlink" title="可以访问的变量"></a>可以访问的变量</h2><p>Lambda表达式的Lambda主体（标准语法中的复合语句）可以包含普通方法或函数的主体可以包含的任何内容。普通函数和Lambda表达式的主体都可以访问以下类型的变量：</p>
<ul>
<li>捕获变量</li>
<li>形参变量</li>
<li>局部声明的变量</li>
<li>类数据成员，当在类内声明<code>this</code>并被捕获时</li>
<li>具有静态存储持续时间的任何变量，例如全局变量</li>
</ul>
<blockquote>
<p>利用lambda来实现闭包的时候不可以捕捉全局变量哦</p>
</blockquote>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>尽量保持lambda变量捕获的简单化</p>
</li>
<li><p>尽量避免捕获指针或者引用，可能变量本身会在捕获和被调用的间隔期间改变，甚至被析构清除</p>
</li>
</ul>
<h2 id="底层"><a href="#底层" class="headerlink" title="底层"></a>底层</h2><ul>
<li>编译器会把一个Lambda表达式生成一个匿名类的<strong>匿名对象</strong>，并在类中<strong>重载函数调用运算符</strong>，实现了一个<code>operator()</code>方法。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> print = []&#123;cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译器会把上面这一句翻译为下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">print_class</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 用构造的类创建对象，print此时就是一个函数对象</span></span><br><span class="line"><span class="keyword">auto</span> print = <span class="built_in">print_class</span>();</span><br></pre></td></tr></table></figure>



<h1 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h1><h2 id="理解一"><a href="#理解一" class="headerlink" title="理解一"></a>理解一</h2><blockquote>
<p>chatgpt生成</p>
</blockquote>
<p><code>std::bind</code> 是一个函数模板，可以将一个可调用对象和一些参数绑定在一起，生成一个新的可调用对象。以下是一些简单的 <code>std::bind</code> 示例：</p>
<ol>
<li>绑定函数和参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void foo(int a, int b, int c) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; &quot;, c = &quot; &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    auto f = std::bind(foo, 1, 2, 3); // 将 foo 函数绑定到 f</span><br><span class="line">    f(); // 调用 f，输出 &quot;a = 1, b = 2, c = 3&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们将函数 <code>foo</code> 绑定到 <code>f</code>，并绑定了三个参数 1、2 和 3。在调用 <code>f()</code> 时，输出了绑定参数后的结果。</p>
<ol>
<li>绑定成员函数和对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">c++Copy code</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">public:</span><br><span class="line">    void bar(int a, int b) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot;, b = &quot; &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Foo obj;</span><br><span class="line">    auto f = std::bind(&amp;Foo::bar, &amp;obj, 1, 2); // 将成员函数 bar 绑定到 f</span><br><span class="line">    f(); // 调用 f，输出 &quot;a = 1, b = 2&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们将成员函数 <code>bar</code> 绑定到 <code>f</code>，并绑定了对象 <code>obj</code> 和两个参数 1 和 2。在调用 <code>f()</code> 时，输出了绑定参数后的结果。</p>
<ol>
<li>绑定函数对象和参数</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">c++Copy code</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Sum &#123;</span><br><span class="line">    int operator()(int a, int b, int c) const &#123;</span><br><span class="line">        return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    Sum s;</span><br><span class="line">    auto f = std::bind(s, 1, 2, 3); // 将函数对象 s 绑定到 f</span><br><span class="line">    std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; f() &lt;&lt; std::endl; // 输出 &quot;sum = 6&quot;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们将函数对象 <code>Sum</code> 绑定到 <code>f</code>，并绑定了三个参数 1、2 和 3。在调用 <code>f()</code> 时，输出了绑定参数后的结果。</p>
<h2 id="理解例子二"><a href="#理解例子二" class="headerlink" title="理解例子二"></a>理解例子二</h2><p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223407992.png"  alt="image-20240625223407992"></p>
<blockquote>
<p>这是用lambda写的传入谓词调用形式</p>
<p>用来完成比较string和一个给定的大小</p>
<p>实在不懂看看下面check_size的实现逻辑</p>
</blockquote>
<hr>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223428831.png"  alt="image-20240625223428831"></p>
<blockquote>
<p>这里是bind的传入谓词调用形式</p>
</blockquote>
<hr>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223442496.png"  alt="image-20240625223442496"></p>
<blockquote>
<p>这里是上面bind传入谓词调用形式中的函数</p>
<p>分析可知：check_size需要传入两个参数</p>
<p>但是我们这个find_if只能接受一个一元谓词，</p>
<p>所以我们需要bind形式来进行小修改</p>
<p>结果如下所示</p>
</blockquote>
<hr>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223505959.png"  alt="image-20240625223505959"></p>
<blockquote>
<p>_1是占位符，起到将 find_if后面调用的时候所传入的唯一参数传入 _1所在的位置</p>
</blockquote>
<hr>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223515442.png"  alt="image-20240625223515442"></p>
<blockquote>
<p><strong>更直观的理解</strong></p>
</blockquote>
<h2 id="绑定引用参数"><a href="#绑定引用参数" class="headerlink" title="绑定引用参数"></a>绑定引用参数</h2><ul>
<li>会有些数据需要以引用形式传入bind，但是自身无法传入引用同时无法又进行拷贝行为的数据类型，如何进行处理？</li>
<li>例子：</li>
</ul>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223526505.png"  alt="image-20240625223526505"></p>
<blockquote>
<p>lambda形式能够很好的完成这个问题</p>
</blockquote>
<hr>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223539256.png"  alt="image-20240625223539256"></p>
<blockquote>
<p>bind如上直接如法炮制可不行</p>
</blockquote>
<hr>
<p><strong>解决办法“采用标准库中的ref（）函数</strong></p>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240625223550406.png"  alt="image-20240625223550406"></p>
<blockquote>
<p>看下面来理解一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; a)</span> </span>&#123;</span><br><span class="line"> ++a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> foo2（<span class="type">const</span> <span class="type">int</span>&amp; a）&#123;</span><br><span class="line"> sdt::cout&lt;&lt;<span class="string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_function</span><span class="params">(std::function&lt;<span class="type">void</span>(<span class="type">void</span>)&gt; fun)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> <span class="built_in">test_function</span>(std::<span class="built_in">bind</span>(foo, a));</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> <span class="built_in">test_function</span>(std::<span class="built_in">bind</span>(foo, std::<span class="built_in">ref</span>(a)));</span><br><span class="line"> std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"> <span class="comment">//test_function(std::bind(foo2,std::cref(a)));</span></span><br><span class="line"> <span class="comment">//这一句甚至编译不通过，靠北，之前作者是可以的，cref好像是适用于传入的参数是常数的才行....为什么呢</span></span><br><span class="line"> std::cout&lt;&lt;<span class="string">&quot;a =&quot;</span> &lt;&lt;a&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/yi-mu-xi/p/9896461.html" >https://www.cnblogs.com/yi-mu-xi/p/9896461.html<i class="fas fa-external-link-alt"></i></a></p>
</blockquote>
<h2 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h2><p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/1681025417055.png"  alt="1681025417055"></p>
<blockquote>
<p>QString 里面的具体实现</p>
</blockquote>
<h1 id="lambda一般应用"><a href="#lambda一般应用" class="headerlink" title="lambda一般应用"></a>lambda一般应用</h1><p>Lambda表达式是C++11引入的一种新特性，它可以创建一个匿名函数对象，常用于在函数中定义一些简短的、局部的函数对象，也可以用于实现函数对象的参数化或泛型编程。</p>
<p>以下是一些常见的Lambda表达式应用例子：</p>
<ol>
<li>STL算法中的Lambda表达式</li>
</ol>
<p>STL算法通常需要一个函数对象作为参数，可以使用Lambda表达式来定义这个函数对象。例如，可以使用Lambda表达式来对一个整数数组进行排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">int arr[] = &#123;3, 1, 4, 1, 5, 9, 2, 6, 5, 3&#125;;</span><br><span class="line">std::sort(std::begin(arr), std::end(arr), [](int a, int b) &#123;</span><br><span class="line">    return a &lt; b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述Lambda表达式定义了一个比较函数，用于对数组中的元素进行排序。</p>
<p>2.C++11线程库中的Lambda表达式</p>
<p>C++11引入了线程库，可以使用Lambda表达式来定义线程的执行代码。例如，可以使用Lambda表达式来创建一个简单的线程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">std::thread t([]() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;);</span><br><span class="line">t.join();</span><br></pre></td></tr></table></figure>

<p>上述Lambda表达式定义了一个函数对象，用于在线程中执行代码。</p>
<p>3.STL容器中的Lambda表达式</p>
<p>Lambda表达式可以用于STL容器中的算法、迭代器和函数对象等。例如，可以使用Lambda表达式来查找一个vector中的最大值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cCopy code</span><br><span class="line">std::vector&lt;int&gt; v = &#123;3, 1, 4, 1, 5, 9, 2, 6, 5, 3&#125;;</span><br><span class="line">auto max_it = std::max_element(v.begin(), v.end(), [](int a, int b) &#123;</span><br><span class="line">    return a &lt; b;</span><br><span class="line">&#125;);</span><br><span class="line">std::cout &lt;&lt; &quot;The maximum value is &quot; &lt;&lt; *max_it &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>上述Lambda表达式定义了一个比较函数，用于查找vector中的最大值。</p>
<p>Lambda表达式的应用不限于上述例子，还可以用于函数式编程、回调函数、闭包等。</p>
<p>4.变量捕获</p>
<p>Lambda函数在C++中被用作匿名函数，它能够捕获外部变量，形成闭包。闭包是一个可调用的对象，它能够访问它创建时所在的上下文中的变量。</p>
<p>Lambda函数可以通过捕获列表来捕获变量。捕获列表是指在方括号<code>[]</code>内部指定的变量列表。捕获列表可以为空，也可以包含以下内容：</p>
<ul>
<li>按值捕获：以值的形式捕获变量，并在lambda表达式内部创建该变量的副本。使用<code>=</code>符号表示按值捕获。例如：<code>[a, b, c]</code>，表示按值捕获变量<code>a</code>、<code>b</code>和<code>c</code>。</li>
<li>按引用捕获：以引用的形式捕获变量，并在lambda表达式内部使用该变量。使用<code>&amp;</code>符号表示按引用捕获。例如：<code>[&amp;x, &amp;y]</code>，表示按引用捕获变量<code>x</code>和<code>y</code>。</li>
<li>按引用捕获但是允许修改：以引用的形式捕获变量，并在lambda表达式内部修改该变量。使用<code>&amp;</code>符号并在变量前面添加<code>mutable</code>关键字表示按引用捕获但是允许修改。例如：<code>[&amp;z]() mutable &#123; z = z + 1; &#125;</code>，表示按引用捕获变量<code>z</code>，并在lambda表达式内部对其进行修改。</li>
</ul>
<p>下面是一个使用闭包的例子，该例子演示了如何使用lambda函数来捕获外部变量，并将其传递给另一个函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c++Copy code</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  std::vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">  int factor = 10;</span><br><span class="line">  </span><br><span class="line">  std::for_each(numbers.begin(), numbers.end(), [factor](int &amp;number) &#123;</span><br><span class="line">    number *= factor;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  std::for_each(numbers.begin(), numbers.end(), [](int number) &#123;</span><br><span class="line">    std::cout &lt;&lt; number &lt;&lt; &quot; &quot;;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，lambda函数中捕获了外部变量<code>factor</code>，并将其作为参数传递给<code>std::for_each</code>函数。<code>std::for_each</code>函数对<code>numbers</code>容器中的每个元素都调用了lambda函数，并将<code>factor</code>乘以每个元素。最后，程序输出了修改后的<code>numbers</code>容器中的每个元素。</p>
<ol start="5">
<li></li>
</ol>
<p>当使用按引用捕获的方式时，可以使用 <code>mutable</code> 关键字允许在 lambda 表达式中修改被捕获的变量。以下是一个示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">c++Copy code</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 10;</span><br><span class="line"></span><br><span class="line">    // lambda 表达式按引用捕获，但允许修改 x 的值</span><br><span class="line">    auto lambda = [&amp;x]() mutable &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">        x = 20;</span><br><span class="line">        std::cout &lt;&lt; &quot;modified x = &quot; &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    lambda(); // 调用 lambda 表达式</span><br><span class="line">    std::cout &lt;&lt; &quot;original x = &quot; &lt;&lt; x &lt;&lt; std::endl; // x 的值被修改了</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，lambda 表达式通过按引用捕获了变量 <code>x</code>，并使用 <code>mutable</code> 关键字允许修改。在 lambda 表达式内部，输出了 <code>x</code> 的值，并将 <code>x</code> 的值修改为 20。在 lambda 表达式调用结束后，输出了 <code>x</code> 的原始值，可以看到变量 <code>x</code> 的值被成功修改了。</p>

                </div>
                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/06/27/20240627-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/"
                                   title="20240627 嵌入式开发"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">20240627 嵌入式开发</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/06/25/20240625-shared-ptr/"
                                   title="20240625 shared_ptr"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">20240625 shared_ptr</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">评论插件加载失败</span>
    <button class="reload keep-button">点击重新加载</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">正在加载评论插件</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="valine-container">
        <div id="vcomments"></div>
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        ></script>
        <script 
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        >
          window.KeepCommentPlugin.initValine = () => {
            const config = {
              el: '#vcomments',
              appId: 'DYpeXIX0A58ayXv2jFns418I-gzGzoHsz',
              appKey: 'aVeRlE1OlBTUKleFs6ZKOrga',
              meta: ['nick', 'mail', 'link'],
              avatar: 'wavatar',
              enableQQ: true,
              placeholder: '请在此输入您的留言',
              lang: 'zh-Hans'.toLowerCase()
            }

            if ('') {
              config.serverURLs = ''
            }

            if (window?.Valine) {
              new Valine(config)
              window.KeepCommentPlugin.hideLoading()
            } else {
              setTimeout(() => {
                window.KeepCommentPlugin.initValine()
              }, 1000)
            }
          }

          if ('false' === 'true') {
            setTimeout(() => {
              window.KeepCommentPlugin.initValine()
            }, 1200)
          } else {
            window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initValine)
          }
        </script>
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#20220819-lambda"><span class="nav-number">1.</span> <span class="nav-text">20220819 lambda</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">闭包的三种实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-operator-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">重载 operator()&#x2F;函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%E4%B9%8B%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="nav-number">5.1.</span> <span class="nav-text">用法之直接调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lambda"><span class="nav-number">6.</span> <span class="nav-text">lambda</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3"><span class="nav-number">6.1.</span> <span class="nav-text">例子理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#args-%E4%BD%BF%E7%94%A8"><span class="nav-number">6.1.1.</span> <span class="nav-text">[    ] ( args )使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8"><span class="nav-number">6.1.2.</span> <span class="nav-text">[ ]用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%96%AD%EF%BC%9F"><span class="nav-number">6.1.3.</span> <span class="nav-text">返回类型可以自动推断？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-lambda-%E6%9C%89%E5%90%8D-lambda"><span class="nav-number">6.1.4.</span> <span class="nav-text">auto lambda&#x2F;有名 lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.5.</span> <span class="nav-text">[ ]传参区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">6.1.6.</span> <span class="nav-text">lambda修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mutable"><span class="nav-number">6.1.6.1.</span> <span class="nav-text">mutable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exception"><span class="nav-number">6.1.6.2.</span> <span class="nav-text">exception</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="nav-number">6.1.7.</span> <span class="nav-text">捕获列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%A1%A8%E7%A4%BA%E4%B8%8D%E6%8D%95%E8%8E%B7%E4%BB%BB%E4%BD%95%E5%8F%98%E9%87%8F"><span class="nav-number">6.1.7.0.1.</span> <span class="nav-text">1.[]表示不捕获任何变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-var-%E8%A1%A8%E7%A4%BA%E5%80%BC%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8Fvar"><span class="nav-number">6.1.7.0.2.</span> <span class="nav-text">2.[var]表示值传递方式捕获变量var</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%A1%A8%E7%A4%BA%E5%80%BC%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88%E5%8C%85%E6%8B%ACthis%EF%BC%89"><span class="nav-number">6.1.7.0.3.</span> <span class="nav-text">3.[&#x3D;]表示值传递方式捕获所有父作用域的变量（包括this）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-var-%E8%A1%A8%E7%A4%BA%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%8D%95%E6%8D%89%E5%8F%98%E9%87%8Fvar"><span class="nav-number">6.1.7.0.4.</span> <span class="nav-text">4.    [&amp;var]表示引用传递捕捉变量var</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%A1%A8%E7%A4%BA%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%8D%95%E6%8D%89%E6%89%80%E6%9C%89%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88%E5%8C%85%E6%8B%ACthis%EF%BC%89"><span class="nav-number">6.1.7.0.5.</span> <span class="nav-text">5.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-this-%E8%A1%A8%E7%A4%BA%E5%80%BC%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%8D%95%E6%8D%89%E5%BD%93%E5%89%8D%E7%9A%84this%E6%8C%87%E9%92%88"><span class="nav-number">6.1.7.0.6.</span> <span class="nav-text">6.[this]表示值传递方式捕捉当前的this指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%BC%95%E7%94%A8%E6%B7%B7%E5%90%88"><span class="nav-number">6.1.7.0.7.</span> <span class="nav-text">7.[&#x3D;, &amp;] 拷贝与引用混合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="nav-number">6.1.7.1.</span> <span class="nav-text">参数列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">基本格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">6.3.</span> <span class="nav-text">可以访问的变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.4.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82"><span class="nav-number">6.5.</span> <span class="nav-text">底层</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bind"><span class="nav-number">7.</span> <span class="nav-text">bind</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E4%B8%80"><span class="nav-number">7.1.</span> <span class="nav-text">理解一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E4%BE%8B%E5%AD%90%E4%BA%8C"><span class="nav-number">7.2.</span> <span class="nav-text">理解例子二</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">7.3.</span> <span class="nav-text">绑定引用参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%E4%B8%89"><span class="nav-number">7.4.</span> <span class="nav-text">例子三</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lambda%E4%B8%80%E8%88%AC%E5%BA%94%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">lambda一般应用</span></a></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">明昧</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#20220819-lambda"><span class="nav-number">1.</span> <span class="nav-text">20220819 lambda</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">闭包的三种实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD-operator-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">重载 operator()&#x2F;函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%B3%95%E4%B9%8B%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8"><span class="nav-number">5.1.</span> <span class="nav-text">用法之直接调用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lambda"><span class="nav-number">6.</span> <span class="nav-text">lambda</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%E7%90%86%E8%A7%A3"><span class="nav-number">6.1.</span> <span class="nav-text">例子理解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#args-%E4%BD%BF%E7%94%A8"><span class="nav-number">6.1.1.</span> <span class="nav-text">[    ] ( args )使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8"><span class="nav-number">6.1.2.</span> <span class="nav-text">[ ]用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E6%8E%A8%E6%96%AD%EF%BC%9F"><span class="nav-number">6.1.3.</span> <span class="nav-text">返回类型可以自动推断？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-lambda-%E6%9C%89%E5%90%8D-lambda"><span class="nav-number">6.1.4.</span> <span class="nav-text">auto lambda&#x2F;有名 lambda</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E5%8F%82%E5%8C%BA%E5%88%AB"><span class="nav-number">6.1.5.</span> <span class="nav-text">[ ]传参区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lambda%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">6.1.6.</span> <span class="nav-text">lambda修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mutable"><span class="nav-number">6.1.6.1.</span> <span class="nav-text">mutable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exception"><span class="nav-number">6.1.6.2.</span> <span class="nav-text">exception</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8"><span class="nav-number">6.1.7.</span> <span class="nav-text">捕获列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%A1%A8%E7%A4%BA%E4%B8%8D%E6%8D%95%E8%8E%B7%E4%BB%BB%E4%BD%95%E5%8F%98%E9%87%8F"><span class="nav-number">6.1.7.0.1.</span> <span class="nav-text">1.[]表示不捕获任何变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-var-%E8%A1%A8%E7%A4%BA%E5%80%BC%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8Fvar"><span class="nav-number">6.1.7.0.2.</span> <span class="nav-text">2.[var]表示值传递方式捕获变量var</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%A1%A8%E7%A4%BA%E5%80%BC%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%8D%95%E8%8E%B7%E6%89%80%E6%9C%89%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88%E5%8C%85%E6%8B%ACthis%EF%BC%89"><span class="nav-number">6.1.7.0.3.</span> <span class="nav-text">3.[&#x3D;]表示值传递方式捕获所有父作用域的变量（包括this）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-var-%E8%A1%A8%E7%A4%BA%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%8D%95%E6%8D%89%E5%8F%98%E9%87%8Fvar"><span class="nav-number">6.1.7.0.4.</span> <span class="nav-text">4.    [&amp;var]表示引用传递捕捉变量var</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E8%A1%A8%E7%A4%BA%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%8D%95%E6%8D%89%E6%89%80%E6%9C%89%E7%88%B6%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88%E5%8C%85%E6%8B%ACthis%EF%BC%89"><span class="nav-number">6.1.7.0.5.</span> <span class="nav-text">5.[&amp;]表示引用传递方式捕捉所有父作用域的变量（包括this）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-this-%E8%A1%A8%E7%A4%BA%E5%80%BC%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%E6%8D%95%E6%8D%89%E5%BD%93%E5%89%8D%E7%9A%84this%E6%8C%87%E9%92%88"><span class="nav-number">6.1.7.0.6.</span> <span class="nav-text">6.[this]表示值传递方式捕捉当前的this指针</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-%E6%8B%B7%E8%B4%9D%E4%B8%8E%E5%BC%95%E7%94%A8%E6%B7%B7%E5%90%88"><span class="nav-number">6.1.7.0.7.</span> <span class="nav-text">7.[&#x3D;, &amp;] 拷贝与引用混合</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="nav-number">6.1.7.1.</span> <span class="nav-text">参数列表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="nav-number">6.2.</span> <span class="nav-text">基本格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%8F%98%E9%87%8F"><span class="nav-number">6.3.</span> <span class="nav-text">可以访问的变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.4.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82"><span class="nav-number">6.5.</span> <span class="nav-text">底层</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bind"><span class="nav-number">7.</span> <span class="nav-text">bind</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E4%B8%80"><span class="nav-number">7.1.</span> <span class="nav-text">理解一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E4%BE%8B%E5%AD%90%E4%BA%8C"><span class="nav-number">7.2.</span> <span class="nav-text">理解例子二</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">7.3.</span> <span class="nav-text">绑定引用参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90%E4%B8%89"><span class="nav-number">7.4.</span> <span class="nav-text">例子三</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lambda%E4%B8%80%E8%88%AC%E5%BA%94%E7%94%A8"><span class="nav-number">8.</span> <span class="nav-text">lambda一般应用</span></a></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->


<!-- lazyload -->


<div class="">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
