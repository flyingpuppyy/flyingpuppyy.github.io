<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="明昧">
    
    <title>
        
            20240506 C加加复习（二） |
        
        行者无畏
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    
<link rel="stylesheet" href="/font/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/font/css/regular.min.css">

    
<link rel="stylesheet" href="/font/css/solid.min.css">

    
<link rel="stylesheet" href="/font/css/brands.min.css">

    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"flyingpuppyy.github.io","root":"/","language":"zh-Hans"}
    KEEP.theme_config = {"base_info":{"primary_color":"#FA8072","title":"行者无畏","author":"明昧","avatar":"/images/tou.jpeg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives","categories":"/categories"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"你过于安静勇敢，我忘了你正在承受苦痛","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":false,"percent":false,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":false,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null}},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":false,"preload":false},"comment":{"enable":true,"use":"valine","valine":{"appid":"DYpeXIX0A58ayXv2jFns418I-gzGzoHsz","appkey":"aVeRlE1OlBTUKleFs6ZKOrga","server_urls":null,"placeholder":"请在此输入您的留言"},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.21"},"waline":{"server_url":null,"reaction":false,"version":2},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":false},"cdn":{"enable":false,"provider":"cdnjs"},"pjax":{"enable":false},"footer":{"since":2020,"word_count":false,"icp":{"enable":false,"record_code":null,"url":"https://beian.miit.gov.cn"},"site_deploy":{"enable":false,"provider":"github","url":null},"shields_style":{"enable":false,"custom":[{"link_url":null,"img_url":null}]}},"inject":{"enable":false,"css":[null],"js":[null]},"encrypt":{"enable":true},"root":"","source_data":{},"version":"4.1.1"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               行者无畏
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                首页
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                归档
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                
                                分类
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >首页</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        20240506 C加加复习（二）
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/tou.jpeg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">明昧</span>
                                
                                    <span class="author-badge">Lv6</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-05-06 19:58:58</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Wed Jun 19 2024 20:00:04 GMT+0800">2024-06-19 20:00:04</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/C-basic/">C++ basic</a></li>
                        
                    
                </ul>
            </span>
        

        

        
        
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body">
                    

                    <h1 id="C-Primer快速回顾"><a href="#C-Primer快速回顾" class="headerlink" title="C++Primer快速回顾"></a>C++Primer快速回顾</h1><h1 id="复习思路"><a href="#复习思路" class="headerlink" title="复习思路"></a>复习思路</h1><ul>
<li>不用一章一章看看，这段时间遇到的问题，当你看到这个目录的时候，想到的问题，感兴趣的问题都可以看，你看知识的目的是为了解决问题，不是纯粹背诵概念，你要明白这一点。</li>
</ul>
<h1 id="看目录想问题"><a href="#看目录想问题" class="headerlink" title="看目录想问题"></a>看目录想问题</h1><ul>
<li>C++语言的三大特性以及相关的代码体现，这样做有什么优点和缺点	</li>
<li>一个C++程序从编写编译到运行的过程</li>
<li>要你自己实现一个字符串的类你要怎样设计拷贝、赋值、析构函数</li>
<li>C++是怎样来管理内存的，和java有什么区别和联系</li>
<li>C++11、C++14的关键新特性有什么</li>
<li>using namespace std,解释一下这句话</li>
<li>虚基类是什么？底层是怎样实现的？</li>
<li>C++一般的作用域规则是什么？</li>
<li>C++的const你要怎样区分和分辨</li>
<li>强制类型转换中可能会出现什么样的错误？</li>
<li>lambda、函数对象是怎么一回事？</li>
<li>函数模板能干什么？</li>
</ul>
<h2 id="一些次级问题和主观感受"><a href="#一些次级问题和主观感受" class="headerlink" title="一些次级问题和主观感受"></a>一些次级问题和主观感受</h2><ul>
<li>感觉写代码就是符合规范写东西，试图在某个时机把一个东西从一个地方传另一个地方并且能够保证被合理的使用</li>
</ul>
<h1 id="C-三大特性"><a href="#C-三大特性" class="headerlink" title="C++三大特性"></a>C++三大特性</h1><ul>
<li><p>C++语言的三大特性？相关的代码体现？代码实现？这样做有什么优点和缺点	？和其他的类比？</p>
</li>
<li><p>其实最大的问题不是你记得了什么，而是你是怎样思考的，现在我的思考范式是什么呢？</p>
</li>
</ul>
<blockquote>
<p>我有一个功能，我需要实现它，我需要一段在框架之下的符合逻辑代码</p>
<p>我有一个框架，我需要代码来理解它</p>
<p>我有一个东西，你想要理解，我找比喻来给你解释，或者是拿基础的东西来给你解释</p>
<hr>
<p>类比</p>
<p>优化</p>
<p>底层</p>
<p>彼此之间到底有什么层次和环节</p>
<p>不同抽象层次之间的底层到底是什么</p>
<p>从代码（函数，数据，类和对象）到寄存器</p>
<p>从一个端口到另一个端口</p>
<p>从一个ip到另一个ip</p>
<p>函数的实现判断和边界是什么</p>
<p>实现这一个功能调动了多少资源</p>
<p>内存如何被管理</p>
<p>是否有一个合理的评估标准和判断标准</p>
</blockquote>
<h2 id="三大特性定义"><a href="#三大特性定义" class="headerlink" title="三大特性定义"></a>三大特性定义</h2><blockquote>
<p>定义</p>
<p>1.<strong>封装</strong> ：封装是将数据和操作数据的方法&#x3D;&#x3D;捆绑在一起&#x3D;&#x3D;的机制，以&#x3D;&#x3D;防止外部&#x3D;&#x3D;对数据的直接访问。 在C++中，封装通常通过&#x3D;&#x3D;类&#x3D;&#x3D;来实现，将数据成员私有化，通过公有成员函数提供对数据的访问和操作。 </p>
<p>2.<strong>继承</strong> ：继承是指一个类可以&#x3D;&#x3D;基于另一个类而创&#x3D;&#x3D;建的机制，新创建的类可以&#x3D;&#x3D;继承基类的属性和方法&#x3D;&#x3D;，并且可以添加新的成员或者重写已有的成员函数。</p>
<p>3.<strong>多态</strong> ：多态是指&#x3D;&#x3D;同一操作在不同对象上具有不同的行为&#x3D;&#x3D;的能力。</p>
<p>在C++中，多态通过虚函数和函数重写来实现。子类可以重写基类的虚函数，当通过基类指针或引用调用这个函数时，根据指针或引用所指向的具体对象的类型，会调用对应的子类函数。</p>
</blockquote>
<h2 id="三大特性优缺点"><a href="#三大特性优缺点" class="headerlink" title="三大特性优缺点"></a>三大特性优缺点</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a><strong>封装</strong></h3><blockquote>
<p>封闭起来，包起来，实现隐藏</p>
<p>通过类来实现</p>
<p>不仅将私有数据封闭起来，也将方法的具体实现隐藏起来</p>
<p>&#x3D;&#x3D;修改类的内部不会影响外部&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;隐藏了方法的实现细节，提高了安全性，代码更方便读和规范&#x3D;&#x3D;</p>
</blockquote>
<p>优点： </p>
<ul>
<li>提高了代码的&#x3D;&#x3D;可维护性和可重用性&#x3D;&#x3D;，因为修改类的内部实现不会影响外部用户。  </li>
<li>&#x3D;&#x3D;隐藏了数据的实现细节，提高了安全性&#x3D;&#x3D;，避免了数据被不合理地</li>
</ul>
<p>缺点： </p>
<ul>
<li>需要&#x3D;&#x3D;编写额外的公有成员函数来访问&#x3D;&#x3D;和操作私有数据，增加了代码量和复杂性。  </li>
<li>有时候 &#x3D;&#x3D;过度的封装可能会导致性能损失&#x3D;&#x3D;，因为需要通过函数调用来访问数据。</li>
</ul>
<hr>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote>
<p>提高代码的复用性</p>
<p>建立类的层次，能够更好管理类</p>
</blockquote>
<p>优点： </p>
<ul>
<li>提高了代码的&#x3D;&#x3D;可重用性&#x3D;&#x3D;，可以在不修改基类代码的情况下扩展类的功能。</li>
<li>通过建立类的&#x3D;&#x3D;层次结构&#x3D;&#x3D;，可以更好地组织和管理代码，提高了代码的可维护性。</li>
</ul>
<p>缺点： </p>
<ul>
<li>可能导致类之间的耦合性增加，&#x3D;&#x3D;增加了代码的复杂性&#x3D;&#x3D;。  </li>
<li>如果不正确使用，可能会导致继承层次结构混乱，难以理解和</li>
</ul>
<hr>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><blockquote>
<p>实现动态绑定</p>
</blockquote>
<ul>
<li>提高了代码的&#x3D;&#x3D;灵活&#x3D;&#x3D;性和可扩展性，允许以通用的方式操作对象，而不需要知道对象的具体类型。</li>
<li>可以在运行时动态确定调用哪个函数，&#x3D;&#x3D;实现了动态绑定&#x3D;&#x3D;，提高了代码的&#x3D;&#x3D;可扩展&#x3D;&#x3D;性。</li>
</ul>
<p>缺点： </p>
<ul>
<li><del>如果过度使用，可能会导致代码难以理解和调试，降低代码的可维护性</del></li>
<li>使用虚函数会带来一定的运行时&#x3D;&#x3D;开销&#x3D;&#x3D;</li>
</ul>
<h1 id="三大特性的具体实现"><a href="#三大特性的具体实现" class="headerlink" title="三大特性的具体实现"></a>三大特性的具体实现</h1><ul>
<li><p>封装：类</p>
</li>
<li><p>继承：子类父类</p>
</li>
<li><p>多态：虚函数和函数重写（调用和重写双方面来实现多态的）</p>
<blockquote>
<p>简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用了子类的成员函数。这种技术可以让父类的指针有“多种形态”。这种类型的识别是在程序运行时定义的，也叫运行时多态。</p>
</blockquote>
</li>
</ul>
<h1 id="虚函数-暗含继承"><a href="#虚函数-暗含继承" class="headerlink" title="虚函数&#x2F;暗含继承"></a>虚函数&#x2F;暗含继承</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>父类中允许子类重写的类</p>
<blockquote>
<p>在 C++ 中，只有&#x3D;&#x3D;公有继承（public inheritance）&#x3D;&#x3D;才能实现虚函数的重写（覆盖）。如果使用私有继承（private inheritance）或保护继承（protected inheritance），则无法重写父类中的虚函数。</p>
<blockquote>
<p>×</p>
<p>#include <iostream><br>using namespace std;</p>
<p>class father<br>{<br>    int num;<br>public:<br>    virtual void printNum()<br>    {<br>        cout &lt;&lt; “father” &lt;&lt; num &lt;&lt; endl;<br>    }</p>
<p>};</p>
<p>class son:private father<br>{<br>public:<br>    void printNum()override<br>    {<br>        cout &lt;&lt; “son” &lt;&lt; endl;<br>    }<br>};</p>
<p>int main()<br>{<br>    father u;<br>    son k;</p>
<pre><code>u.printNum();
k.printNum();
        
return 0;
</code></pre>
<p>}</p>
<p>编译通过</p>
<p>并且能够正常运行</p>
</blockquote>
</blockquote>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>虚函数的实现是由两个部分组成的，虚<a class="link"   target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88&spm=1001.2101.3001.7020" >函数指针<i class="fas fa-external-link-alt"></i></a>与虚函数表。</p>
<p>2.1 虚函数指针</p>
<p>为了指定对象的虚表，对象内部包含一个虚表的指针，来指向自己所使用的虚表。为了让&#x3D;&#x3D;每个包含虚表的类的对象都拥有一个虚表指针&#x3D;&#x3D;，编译器在类中添加了一个私有指针，*__vptr，用来指向虚表。</p>
<p>这样，当类的对象在创建时便拥有了这个指针，且这个指针的值会自动被设置为指向类的虚表。</p>
<p>只有拥有虚函数的类才会拥有虚函数指针，所以拥有虚函数的类的所有对象都会因为虚函数产生额外的开销，并且也会在一定程度上降低程序速度。与JAVA不同，C++将是否使用虚函数这一权利交给了开发者，所以开发者应该谨慎的使用。</p>
<p><img   src="/../imgs/$%7Bfiilename%7D/1715010423132.png"  alt="1715010423132"></p>
<blockquote>
<p>自己尝试理解这张图：</p>
<p>同一个类的对象所拥有虚指针是相同的，且所拥有的虚指针所指向的表也是相同的</p>
</blockquote>
<hr>
<p>2.2 虚函数表</p>
<p>虚函数表是一个类的虚函数的地址表，用于索引类本身以及父类的虚函数的地址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的虚函数替换为子类的 虚函数的地址；</p>
<p>虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处）， 它指向对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应 不同基类的虚函数表。</p>
<p>&#x3D;&#x3D;虚表是属于类的，对于基类与派生类，基类有基类的虚函数表，派生类有派生类的虚函数表。&#x3D;&#x3D;</p>
<blockquote>
<p>不同类的对象所拥有的虚指针是不同的</p>
<p>存在继承关系的类的虚函数指针关系和虚表关系是怎么样的呢？</p>
<p>有重叠的部分吗？</p>
</blockquote>
<p>举个例子，定义三个类A,B,C依次继承</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_data1;</span><br><span class="line">	<span class="type">int</span> m_data2;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassB</span>:<span class="keyword">public</span> ClassA</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> </span><br><span class="line">	<span class="type">int</span> m_data3;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 非虚函数，基类的同名函数会被隐藏</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassC</span> :<span class="keyword">public</span> ClassB</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">int</span> m_data1;</span><br><span class="line">	<span class="type">int</span> m_data4;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 非虚函数，基类的同名函数会被隐藏</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果想要观察的话最好就是获取虚指针，观察其所指向的内容的对应索引们的位置和对应的函数代码存储的位置是否相同</p>
</blockquote>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240615121550566.png"  alt="image-20240615121550566"></p>
<p>三、一些遗留问题</p>
<p>1、 构造函数是否能为虚函数？</p>
<p>不能，</p>
<p>1）如果构造函数是虚函数，那么就需要通过虚表指针vtable 来调用，但此时面对一块没有初始化的内存，到哪里去找 vtable 呢？毕竟，vtable 是在构造函数中才初始化的啊，而不是在其之前。因此构造函数不能为虚函数。</p>
<p>2）构造函数在进行调用时还不存在父类和子类的概念，父类只会调用父类的构造函数，子类调用子类 的，因此不存在动态绑定的概念</p>
<p>2、析构函数可以是虚函数吗？</p>
<p>可以，而且最好是虚的，因为此时 vtable 已经初始化了；况且我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。</p>
<p>3、使用虚函数的时候，子类也要使用virtual关键字吗？</p>
<p>父类使用虚函数是为了让子类重写，那子类重写的时候也需要带virtual关键字吗？比如：<br><img   src="/imgs/$%7Bfiilename%7D/1715011371491.png"  alt="1715011371491"></p>
<p>4、构造函数中可以调用虚函数吗？</p>
<p>可以，但是没有动态绑定的效果，父类构造函数中调用的仍然是父类版本的函数，子类中调用的仍然是子类版本的函数</p>
<p>5、内联函数、静态成员函数可以是虚函数吗？（&#x3D;&#x3D;看到虚函数的运行实现时机和其他机制的实现时机是不一样的&#x3D;&#x3D;）</p>
<blockquote>
</blockquote>
<p>内联函数可以，但是不要这么写。内联函数需要在编译阶段展开，而虚函数是运行时动态绑定的，编译时无法展开，当然你可以写 inline virtual 这样的函数，它也不报错，因为内联是编译器决定的，并不跟是否有关键字inline有关系。而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联；</p>
<p>静态成员函数不可以，因为它是以类为单位的函数，与具体对象无关，无this指针，虚函数是与对象动态绑定的，必定是成员函数，成员函数肯定有this指针，因此是两个冲突的概念；</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_31608641/article/details/104801425" >https://blog.csdn.net/sinat_31608641/article/details/104801425<i class="fas fa-external-link-alt"></i></a></p>
<p>睡觉</p>
<p>…….</p>
<h1 id="内联函数的实现"><a href="#内联函数的实现" class="headerlink" title="内联函数的实现"></a>内联函数的实现</h1><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35902025/article/details/127912415" >https://blog.csdn.net/qq_35902025/article/details/127912415<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>基本问题思路：</p>
<p>什么是内联函数</p>
<p>为什么需要使用内联函数</p>
</blockquote>
<h2 id="什么是内联函数"><a href="#什么是内联函数" class="headerlink" title="什么是内联函数"></a>什么是内联函数</h2><h4 id="1-直观上定义："><a href="#1-直观上定义：" class="headerlink" title="1.直观上定义："></a>1.<strong>直观上定义：</strong></h4><p>联函数的定义与普通函数基本相同,只是在函数定义前加上关键字 inline。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-更深入的思考："><a href="#2-更深入的思考：" class="headerlink" title="2.更深入的思考："></a>2.<strong>更深入的思考：</strong></h4><ul>
<li>函数前面加上inline一定会有效果吗？</li>
<li>如果不加inline就不是内联函数了吗？</li>
</ul>
<p>后面让我们慢慢来解答这两个问题</p>
<h2 id="为什么使用内联函数"><a href="#为什么使用内联函数" class="headerlink" title="为什么使用内联函数"></a>为什么使用内联函数</h2><ul>
<li><strong>内联函数最初的目的：*代替部分 #define 宏定义</strong>；</li>
<li><strong>使用内联函数替代普通函数的目的：提高程序的运行效率；</strong></li>
</ul>
<p>针对上述两个方面我们展开讨论</p>
<p><strong>1.为什么要代替部分宏定义</strong></p>
<blockquote>
<p>宏是预处理指令，在预处理的时候把所有的宏名用宏体来替换；</p>
<p>内联函数是函数，在编译阶段把所有调用内联函数的地方把内联函数插入；</p>
<hr>
<p>宏没有类型检查，无论对还是错都是直接替换；</p>
<p>而内联函数在编译时进行安全检查；</p>
<hr>
<p>宏的编写有很多限制，例如只能写一行，不能使用return控制流程等；</p>
<hr>
<p>对于C++ 而言，使用宏代码还有另一种缺点：无法操作类的私有数据成员。</p>
</blockquote>
<p><strong>2.普通函数频繁调用的过程消耗栈空间</strong></p>
<p>函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。</p>
<p>一个 C&#x2F;C++程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的起点是main()，终点也是main()。当main()调用完了所有的函数，它会返回一个值（例如return 0;）来结束自己的生命，从而结束整个程序。</p>
<p>函数调用是有时间和空间开销的。程序在执行一个函数之前需要做一些准备工作，要将实参、局部变量、返回地址以及若干寄存器都<strong>压入栈</strong>中，然后才能<strong>执行函数体中的代码</strong>；函数体中的代码执行完毕后还要<strong>清理现场</strong>，将之前压入栈中的数据都出栈，才能接着执行函数调用位置以后的代码。</p>
<blockquote>
<p>数据和函数都压入栈，执行代码，执行完毕后要清理现场&#x2F;实现出栈</p>
</blockquote>
<p>栈空间就是指放置程式的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程式出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p>
<p>如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；</p>
<p>如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。</p>
<blockquote>
<p>总结：函数调用机制所产生的开销（栈的空间开销和出栈入栈的时间开销）</p>
</blockquote>
<hr>
<p>为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function）。但也存在缺点，就是每一调用处均会展开，增加了重复的代码量。</p>
<blockquote>
<p>可以理解为内联函数的关键词是：<strong>替换</strong></p>
</blockquote>
<h2 id="展开的关键"><a href="#展开的关键" class="headerlink" title="展开的关键"></a>展开的关键</h2><h4 id="3-更深入的思考"><a href="#3-更深入的思考" class="headerlink" title="3.更深入的思考"></a><strong>3.更深入的思考</strong></h4><p>通过上述内容我们知道内联函数是在调用的地方展开函数定义，那么问题又来了，展开也好，替换也好，都存在下面两个问题：</p>
<ul>
<li>内联函数一定就会展开吗？</li>
<li>在什么情况下内联函数会展开？</li>
</ul>
<p>三.内联函数和编译过程的相爱相杀</p>
<p>在这一节，我们先一口气回答前两节的所有问题，然后慢慢引出后面的话题。</p>
<blockquote>
<p>函数前面加上inline一定会有效果吗</p>
<p>如果不加inline就不是内联函数了吗？</p>
<p>内联函数一定就会展开吗？</p>
<p>在什么情况下内联函数会展开？</p>
<blockquote>
<p>关键 inline到底起没起作用&#x2F;展开与否&#x2F;效果与否</p>
</blockquote>
</blockquote>
<hr>
<p>函数前面加上inline一定会有效果吗</p>
<blockquote>
<p>不会，使用内联inline关键字修饰函数只是一种提示，编译器不一定认。</p>
</blockquote>
<p>如果不加inline就不是内联函数了吗？</p>
<blockquote>
<p><strong>存在隐式内联，不用inline关键字，C++中在类内定义的所有函数都自动称为内联函数。</strong></p>
</blockquote>
<p>内联函数一定就会展开吗？</p>
<blockquote>
<p>其实和第一个问题类似，还是看编译器认不认。</p>
</blockquote>
<p>在什么情况下内联函数会展开？</p>
<blockquote>
<p> 首先需要满足有inline修饰或者是类中的定义的函数，然后再&#x3D;&#x3D;由编译器决定（关键）&#x3D;&#x3D;。 </p>
</blockquote>
<hr>
<hr>
<p><strong>其实说白了，内联函数管不管用是由编译器说了算的！</strong></p>
<p><strong>那如何要求编译器展开内联函数呢？</strong></p>
<blockquote>
<p>1.编译器开优化：gcc -O2 test.c -o test，只有在编译器&#x3D;&#x3D;开启优化选项&#x3D;&#x3D;的时候，才会有inline行为的存在，比如对g++在-O0时就不会作任何的inline处理，对于-O2的优化方式，编译器会通过启发式算法决定是否值得对一个函数进行内联，同时要保证不会对生成文件的大小产生较大影响。 而-O3模式则不在考虑生成文件的大小；</p>
<p>2.使用attribute属性：static inline <strong>attribute</strong>((always_inline)) int add_i(int a,int b)；</p>
<p>3.使用auto_inline：#pragma auto_inline(on&#x2F;off)，当使用#pragma auto_inline(off)指令时，会关闭对函数的inline处理，这时即使在函数前面加了inline指令，也不会对函数进行内联处理。</p>
</blockquote>
<p>上述操作都仅仅是对编译器提出内联的建议，最终是否进行内联由编译器自己决定，大多数编译器拒绝它们认为太复杂的内联函数（例如，那些包含循环或者递归的），而且类的构造函数、析构函数和虚函数往往不是内联函数的最佳选择。</p>
<p>有关visual studio中编译优化选择的位置如图，gcc编译见上面的例子也可以直接man gcc查看。</p>
<p><img   src="https://raw.githubusercontent.com/flyingpuppyy/pic/main/images/image-20240615121608339.png"  alt="image-20240615121608339"></p>
<h2 id="内联函数怎么用，在哪儿用？"><a href="#内联函数怎么用，在哪儿用？" class="headerlink" title="内联函数怎么用，在哪儿用？"></a>内联函数怎么用，在哪儿用？</h2><p>基本介绍完内联的概念，接下来说说内联怎么用，在哪儿用？</p>
<p><strong>内联函数是定义在头文件还是源文件？</strong></p>
<p>内联展开是在编译时进行的，只有链接的时候源文件之间才有关系。</p>
<p>1.所以内联要想跨源文件必须把实现&#x3D;&#x3D;写在头文件里&#x3D;&#x3D;。</p>
<blockquote>
<p>2.&#x3D;&#x3D;如果一个内联函数会在多个源文件中被用到，那么必须把它定义在头文件中&#x3D;&#x3D;</p>
<p>3.内联函数的定义不一定要跟声明放在一个头文件里面：</p>
<p>4.&#x3D;&#x3D;定义可以放在一个单独的头文件中，里面需要给函数定义前加上inline 关键字&#x3D;&#x3D;，</p>
<blockquote>
<p>这里到底想讲什么</p>
</blockquote>
</blockquote>
<p>原因看下面第 2.点；然后声明 放在另一个头文件中，此文件include上一个头文件。</p>
<p>这种用法 boost里很常见：优点1. 实现跟API分离封装。优点2. 可以解决有关inline函数的循环调用问题。</p>
<p>1.隐式内联：如第三节说的C++中在类内定义的所有函数都自动称为内联函数，类的成员函数的定义直接写在类的声明中时，不需要inline关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trace</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Trace</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		noisy = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (noisy)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span></span>&#123; noisy = <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span></span>&#123; noisy = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> noisy;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.<strong>显式内联：</strong>需要使用<strong>inline</strong>关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trace</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Trace</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		noisy = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> *s)</span></span>; <span class="comment">//类内没有显示声明</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">on</span><span class="params">()</span></span>&#123; noisy = <span class="number">1</span>; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">off</span><span class="params">()</span></span>&#123; noisy = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> noisy;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外显示定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Trace::print</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (noisy)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="内联函数和重定义"><a href="#内联函数和重定义" class="headerlink" title="内联函数和重定义"></a>内联函数和重定义</h2><p><strong>这一部分我们带着问题一步步进行分析思考</strong></p>
<p><strong>什么是重定义？</strong></p>
<p>答：C&#x2F;C++语法中，如果变量、函数在同一个工程中被多次定义，链接期间会报类似“对 xxx 多重定义”的错误。</p>
<p>当内联函数的声明和定义分别在头文件和源文件中，并且在其他文件中被调用时，链接期间编译器会报“对 xxx 未定义的引用”错误。&#x3D;&#x3D;内联函数如果会在多处被调用，则需要将函数的定义写在头文件中。&#x3D;&#x3D;</p>
<p>为什么inline关键字修饰的函数定义在头文件中（函数可能会被多次定义），编译器不会报“对 xxx 多重定义”的错误呢？</p>
<p>答：编译器对被inline修饰的函数做了特殊处理，inline起到了内联的作用</p>
<hr>
<p><strong>inline为什么能起作用？</strong></p>
<p>答：因为inline是一个弱符号；</p>
<hr>
<p><strong>什么是弱符号？</strong></p>
<p>答：在C语言中，编译器默认函数和初始化了的全局变量为强符号（Strong Symbol），未初始化的全局变量为弱符号（Weak Symbol）。</p>
<p>强符号之所以强，是因为它们拥有确切的数据，变量有值，函数有函数体；弱符号之所以弱，是因为它们还未被初始化，没有确切的数据。</p>
<p>链接器会按照如下的规则处理被多次定义的强符号和弱符号：</p>
<ol>
<li><p>不允许强符号被多次定义，也即不同的目标文件中不能有同名的强符号；如果有多个强符号，那么链接器会报符号重复定义错误。</p>
</li>
<li><p>如果一个符号在某个目标文件中是强符号，在其他文件中是弱符号，那么选择强符号。</p>
</li>
<li><p>如果一个符号在所有的目标文件中都是弱符号，那么选择其中占用空间最大的一个。</p>
</li>
</ol>
<hr>
<p><strong>怎么知道inline是个弱符号的？</strong></p>
<p>答：反汇编：objdump -dS test，看下面两个例子：</p>
<p>下面两个.cpp文件，除Function()的inline修饰符外其他内容完全一致</p>
<p>1.正常的函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* NormalMain.cpp */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[Function]========= Get!!!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Function</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>汇编结果 ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	.file	<span class="string">&quot;NormalMain.cpp&quot;</span></span><br><span class="line">	.section	.rodata</span><br><span class="line">.LC0:</span><br><span class="line">	.string	<span class="string">&quot;[Function]========= Get!!!&quot;</span></span><br><span class="line">	.text</span><br><span class="line">	.globl	_Z8Functionv</span><br><span class="line">	.type	_Z8Functionv, @function</span><br><span class="line">_Z8Functionv:</span><br><span class="line">;...</span><br></pre></td></tr></table></figure>

<p>……</p>
<blockquote>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35902025/article/details/127912415" >https://blog.csdn.net/qq_35902025/article/details/127912415<i class="fas fa-external-link-alt"></i></a></p>
<p>讲到汇编已经开始吐血了</p>
<p>我只想了解到内联函数和C++的关系就好了</p>
</blockquote>

                </div>
                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2024/05/07/20240507-C%E5%8A%A0%E5%8A%A0%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"
                                   title="20240507 C加加复习（三）"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">20240507 C加加复习（三）</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2024/05/06/20240506-C%E5%8A%A0%E5%8A%A0%E5%A4%8D%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"
                                   title="20240506 C加加复习（一）"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">20240506 C加加复习（一）</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">评论插件加载失败</span>
    <button class="reload keep-button">点击重新加载</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">正在加载评论插件</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="valine-container">
        <div id="vcomments"></div>
        <script 
                src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        ></script>
        <script 
                async
                onerror="window.KeepCommentPlugin.loadFailHandle()"
        >
          window.KeepCommentPlugin.initValine = () => {
            const config = {
              el: '#vcomments',
              appId: 'DYpeXIX0A58ayXv2jFns418I-gzGzoHsz',
              appKey: 'aVeRlE1OlBTUKleFs6ZKOrga',
              meta: ['nick', 'mail', 'link'],
              avatar: 'wavatar',
              enableQQ: true,
              placeholder: '请在此输入您的留言',
              lang: 'zh-Hans'.toLowerCase()
            }

            if ('') {
              config.serverURLs = ''
            }

            if (window?.Valine) {
              new Valine(config)
              window.KeepCommentPlugin.hideLoading()
            } else {
              setTimeout(() => {
                window.KeepCommentPlugin.initValine()
              }, 1000)
            }
          }

          if ('false' === 'true') {
            setTimeout(() => {
              window.KeepCommentPlugin.initValine()
            }, 1200)
          } else {
            window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initValine)
          }
        </script>
    </div>


        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-Primer%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.</span> <span class="nav-text">C++Primer快速回顾</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E4%B9%A0%E6%80%9D%E8%B7%AF"><span class="nav-number">2.</span> <span class="nav-text">复习思路</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9C%8B%E7%9B%AE%E5%BD%95%E6%83%B3%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">看目录想问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%AC%A1%E7%BA%A7%E9%97%AE%E9%A2%98%E5%92%8C%E4%B8%BB%E8%A7%82%E6%84%9F%E5%8F%97"><span class="nav-number">3.1.</span> <span class="nav-text">一些次级问题和主观感受</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">C++三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">三大特性定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.2.</span> <span class="nav-text">三大特性优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">4.2.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">4.2.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">4.2.3.</span> <span class="nav-text">多态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">三大特性的具体实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-%E6%9A%97%E5%90%AB%E7%BB%A7%E6%89%BF"><span class="nav-number">6.</span> <span class="nav-text">虚函数&#x2F;暗含继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.2.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.</span> <span class="nav-text">内联函数的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">7.1.</span> <span class="nav-text">什么是内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%9B%B4%E8%A7%82%E4%B8%8A%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">7.1.0.1.</span> <span class="nav-text">1.直观上定义：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%9A"><span class="nav-number">7.1.0.2.</span> <span class="nav-text">2.更深入的思考：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">为什么使用内联函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E5%BC%80%E7%9A%84%E5%85%B3%E9%94%AE"><span class="nav-number">7.3.</span> <span class="nav-text">展开的关键</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">7.3.0.1.</span> <span class="nav-text">3.更深入的思考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E5%9C%A8%E5%93%AA%E5%84%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">7.4.</span> <span class="nav-text">内联函数怎么用，在哪儿用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E9%87%8D%E5%AE%9A%E4%B9%89"><span class="nav-number">7.5.</span> <span class="nav-text">内联函数和重定义</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="border-box website-info-box default">
        
            <div class="copyright-info info-item default">
                &copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024
                
                    &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">明昧</a>
                
            </div>

            <div class="theme-info info-item default">
                由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
            </div>

            

            
        

        <div class="count-item info-item default">
            

            
                <span class="count-box border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-box border-box pv">
                    <span class="item-type border-box">访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    </div>
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-Primer%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.</span> <span class="nav-text">C++Primer快速回顾</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E4%B9%A0%E6%80%9D%E8%B7%AF"><span class="nav-number">2.</span> <span class="nav-text">复习思路</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9C%8B%E7%9B%AE%E5%BD%95%E6%83%B3%E9%97%AE%E9%A2%98"><span class="nav-number">3.</span> <span class="nav-text">看目录想问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%AC%A1%E7%BA%A7%E9%97%AE%E9%A2%98%E5%92%8C%E4%B8%BB%E8%A7%82%E6%84%9F%E5%8F%97"><span class="nav-number">3.1.</span> <span class="nav-text">一些次级问题和主观感受</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">4.</span> <span class="nav-text">C++三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%AE%9A%E4%B9%89"><span class="nav-number">4.1.</span> <span class="nav-text">三大特性定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.2.</span> <span class="nav-text">三大特性优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85"><span class="nav-number">4.2.1.</span> <span class="nav-text">封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">4.2.2.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">4.2.3.</span> <span class="nav-text">多态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.</span> <span class="nav-text">三大特性的具体实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0-%E6%9A%97%E5%90%AB%E7%BB%A7%E6%89%BF"><span class="nav-number">6.</span> <span class="nav-text">虚函数&#x2F;暗含继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">6.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.2.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.</span> <span class="nav-text">内联函数的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">7.1.</span> <span class="nav-text">什么是内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%9B%B4%E8%A7%82%E4%B8%8A%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="nav-number">7.1.0.1.</span> <span class="nav-text">1.直观上定义：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E6%80%9D%E8%80%83%EF%BC%9A"><span class="nav-number">7.1.0.2.</span> <span class="nav-text">2.更深入的思考：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">为什么使用内联函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E5%BC%80%E7%9A%84%E5%85%B3%E9%94%AE"><span class="nav-number">7.3.</span> <span class="nav-text">展开的关键</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E6%80%9D%E8%80%83"><span class="nav-number">7.3.0.1.</span> <span class="nav-text">3.更深入的思考</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E5%9C%A8%E5%93%AA%E5%84%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">7.4.</span> <span class="nav-text">内联函数怎么用，在哪儿用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E9%87%8D%E5%AE%9A%E4%B9%89"><span class="nav-number">7.5.</span> <span class="nav-text">内联函数和重定义</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->

<script src="/js/utils.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/toggle-theme.js"></script>

<script src="/js/code-block.js"></script>

<script src="/js/main.js"></script>

<script src="/js/libs/anime.min.js"></script>


<!-- local-search -->


<!-- lazyload -->


<div class="">
    
        <!-- post-helper -->
        
<script src="/js/post/post-helper.js"></script>


        <!-- toc -->
        
            
<script src="/js/post/toc.js"></script>

        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->



</body>
</html>
